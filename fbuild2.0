// fbuild - Gerenciador source-based com binários (Fernando Edition)
// Linguagem: C++17
// Compilar: g++ -std=c++17 -O2 -pthread -o fbuild main.cpp
// Runtime deps: bash, git, curl, tar/bsdtar, unzip, xz, 7z, patch, zstd, sha256sum (fakeroot opcional)

#include <algorithm>
#include <atomic>
#include <chrono>
#include <csignal>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <filesystem>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <mutex>
#include <regex>
#include <set>
#include <sstream>
#include <string>
#include <thread>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;
namespace fs = std::filesystem;

// ========================= ANSI =========================
namespace ansi {
    const string reset="\033[0m";
    const string bold="\033[1m";
    const string dim="\033[2m";
    const string red="\033[31m";
    const string green="\033[32m";
    const string yellow="\033[33m";
    const string blue="\033[34m";
    const string magenta="\033[35m";
    const string cyan="\033[36m";
    const string gray="\033[90m";
}
static bool g_no_color = false;
static bool g_quiet = false;
static bool g_yes = false;
static int  g_jobs = max(1u, thread::hardware_concurrency());
static bool g_verbose = true;

string C(const string& color){ return g_no_color? string(""): color; }

// ========================= Utilidades gerais =========================
string getenvs(const string &k, const string &def=""){ const char* v=getenv(k.c_str()); return v? string(v):def; }
bool existsPath(const string &p){ return access(p.c_str(), F_OK)==0; }
void ensureDir(const string &p){ if(!existsPath(p)) fs::create_directories(p); }
string joinPath(const string &a, const string &b){ if(a.empty()) return b; if(a.back()=='/') return a+b; return a+"/"+b; }
string timestamp(){ time_t t=time(nullptr); char buf[64]; strftime(buf,64,"%Y-%m-%d_%H-%M-%S",localtime(&t)); return buf; }

string shellEscape(const string &s){
    string out; out.reserve(s.size()*2);
    for(unsigned char c: s){
        if(isalnum(c) || c=='/'||c=='_'||c=='.'||c=='-'||c=='+') out.push_back(c);
        else { out.push_back('\\'); out.push_back(c); }
    }
    return out;
}

bool haveCmd(const string &cmd){ string c = "bash -lc 'command -v "+shellEscape(cmd)+" >/dev/null'"; return system(c.c_str())==0; }
void requireCmds(const vector<string>&cmds){
    vector<string> missing;
    for(auto &c:cmds) if(!haveCmd(c)) missing.push_back(c);
    if(!missing.empty()){
        cerr<<C(ansi::red)<<"Faltam dependências no PATH: ";
        for(size_t i=0;i<missing.size();++i) cerr<<missing[i]<<(i+1<missing.size()?", ":"");
        cerr<<C(ansi::reset)<<"\n"; exit(2);
    }
}

// ========================= Spinner =========================
class Spinner {
    atomic<bool> running{false};
    thread th; string msg;
public:
    void start(const string &m){ msg=m; running=true; th=thread([&]{
        const char* frames="|/-\\"; int i=0;
        while(running){
            if(!g_quiet) {
                cerr << "\r" << C(ansi::cyan) << frames[i++%4] << C(ansi::reset) << " " << msg << "   "; 
                cerr.flush();
            }
            this_thread::sleep_for(chrono::milliseconds(100));
        }
        if(!g_quiet){
            cerr << "\r" << string(msg.size()+8,' ') << "\r"; cerr.flush();
        }
    }); }
    void stopOk(){ running=false; if(th.joinable()) th.join(); if(!g_quiet) cerr<<C(ansi::green)<<"✔ "<<msg<<C(ansi::reset)<<"\n"; }
    void stopFail(){ running=false; if(th.joinable()) th.join(); if(!g_quiet) cerr<<C(ansi::red)<<"✖ "<<msg<<C(ansi::reset)<<"\n"; }
};

// ========================= Config =========================
struct Config{
    string REPO = getenvs("REPO", string(getenvs("HOME"))+"/.fbuild/repo");
    string CACHE = getenvs("FB_CACHE", string(getenvs("HOME"))+"/.cache/fbuild");
    string WORK = getenvs("FB_WORK", string(getenvs("HOME"))+"/.local/share/fbuild/work");
    string PKG = getenvs("FB_PKG", string(getenvs("HOME"))+"/.local/share/fbuild/packages");
    string DB = getenvs("FB_DB", string(getenvs("HOME"))+"/.local/share/fbuild/db");
    string LOG = getenvs("FB_LOG", string(getenvs("HOME"))+"/.local/share/fbuild/log");
    string DESTDIR = getenvs("DESTDIR", "/"); // raiz alvo
    bool USE_FAKEROOT = getenvs("FB_USE_FAKEROOT","0")=="1";
} cfg;

void ensureBaseDirs(){
    for(auto &d: {cfg.REPO, cfg.CACHE, cfg.WORK, cfg.PKG, cfg.DB, cfg.LOG}) ensureDir(d);
    for(auto &sub: {string("base"),string("x11"),string("extras"),string("desktop"),string("hooks")}) ensureDir(joinPath(cfg.REPO, sub));
    ensureDir(joinPath(cfg.PKG,"bin")); // onde ficam os .tar.zst
}

// ========================= Logs =========================
string actionLog(const string &name,const string &action){ return joinPath(cfg.LOG, name+"-"+action+"-"+timestamp()+".log"); }

// ========================= Exec shell =========================
int sh_raw(const string &cmd){
    if(g_verbose && !g_quiet) cerr<<C(ansi::gray)<<"→ "<<cmd<<C(ansi::reset)<<"\n";
    return system(cmd.c_str());
}
int sh(const string &cmd, const string &logfile=""){
    if(logfile.empty()) return sh_raw(cmd);
    string real = "bash -lc '" + cmd + "'"; // para redirecionamentos, etc.
    real += " >>" + shellEscape(logfile) + " 2>&1";
    return sh_raw(real);
}

// ========================= Versões e dependências =========================
int cmpVersion(const string &a, const string &b){
    // comparação simples numérica por tokens [0-9A-Za-z]+ separados por ._- (suficiente p/ maioria)
    auto split = [](const string&s){ vector<string> t; string cur; 
        for(char c: s){ if(c=='.'||c=='-'||c=='_'){ if(!cur.empty()){t.push_back(cur); cur.clear();} } else cur.push_back(c); }
        if(!cur.empty()) t.push_back(cur); return t; };
    auto ta=split(a), tb=split(b);
    size_t n=max(ta.size(), tb.size());
    for(size_t i=0;i<n;i++){
        string xa = i<ta.size()?ta[i]:"0";
        string xb = i<tb.size()?tb[i]:"0";
        bool na=all_of(xa.begin(),xa.end(),::isdigit);
        bool nb=all_of(xb.begin(),xb.end(),::isdigit);
        if(na && nb){
            long long ia=stoll(xa), ib=stoll(xb);
            if(ia<ib) return -1; if(ia>ib) return 1;
        } else {
            int c=xa.compare(xb); if(c<0) return -1; if(c>0) return 1;
        }
    }
    return 0;
}

struct DepSpec{
    string name;
    // múltiplas restrições: >=1.2, <2.0, =1.3.5, etc.
    vector<pair<string,string>> constraints; // op, ver
};

DepSpec parseDep(const string &s){
    // aceita: "pkg", "pkg>=1.2", "pkg<=2.0", "pkg=1.0", "pkg>1.0", "pkg<2.0"
    DepSpec d;
    // remove espaços
    string t; for(char c: s) if(!isspace((unsigned char)c)) t.push_back(c);
    regex re("^([A-Za-z0-9_+.-]+)(.*)$");
    smatch m; if(regex_match(t,m,re)){ d.name=m[1]; string rest=m[2];
        regex rc("([<>]=?|=)([0-9A-Za-z.+:_-]+)");
        auto it= sregex_iterator(rest.begin(), rest.end(), rc);
        for(; it!=sregex_iterator(); ++it) d.constraints.push_back({(*it)[1], (*it)[2]});
    } else d.name=t;
    return d;
}

bool satisfies(const string &version, const vector<pair<string,string>>& cons){
    for(auto &c: cons){
        int cmp=cmpVersion(version, c.second);
        if(c.first=="=" && cmp!=0) return false;
        if(c.first==">=" && !(cmp>=0)) return false;
        if(c.first=="<=" && !(cmp<=0)) return false;
        if(c.first==">" && !(cmp>0)) return false;
        if(c.first=="<" && !(cmp<0)) return false;
    }
    return true;
}

// junta restrições (interseção); retorna false se conflito
bool mergeConstraints(vector<pair<string,string>>& base, const vector<pair<string,string>>& add){
    base.insert(base.end(), add.begin(), add.end());
    // checagem simples: encontre menor upper e maior lower e verifique intersecção
    // (para igualdade, forçamos lower=upper)
    string eq=""; vector<pair<string,string>> lowers, uppers;
    for(auto &c: base){
        if(c.first=="="){ if(eq.empty()) eq=c.second; else if(cmpVersion(eq,c.second)!=0) return false; }
        else if(c.first=="<"||c.first=="<=") uppers.push_back(c);
        else if(c.first==">"||c.first==">=") lowers.push_back(c);
    }
    if(!eq.empty()){
        // se equality existe, todos devem aceitar eq
        for(auto &c: base){ if(c.first!="="){ if(!satisfies(eq,{c})) return false; } }
    } else {
        // pegue maior dos lowers e menor dos uppers e teste um ponto médio aproximado (usaremos limites)
        // heurística: apenas valida que lower <= upper aprox
        auto betterLower=[&](pair<string,string>a,pair<string,string>b){
            int cmp=cmpVersion(a.second,b.second);
            if(cmp<0) return b; if(cmp>0) return a;
            // se mesma versão, '>' é mais restritivo que '>='
            if(a.first==">" && b.first==">=") return a;
            return b;
        };
        auto betterUpper=[&](pair<string,string>a,pair<string,string>b){
            int cmp=cmpVersion(a.second,b.second);
            if(cmp<0) return a; if(cmp>0) return b;
            // se mesma versão, '<' é mais restritivo que '<='
            if(a.first=="<" && b.first=="<=") return a;
            return b;
        };
        if(!lowers.empty()){
            auto L=lowers[0]; for(size_t i=1;i<lowers.size();++i) L=betterLower(L, lowers[i]); lowers={L};
        }
        if(!uppers.empty()){
            auto U=uppers[0]; for(size_t i=1;i<uppers.size();++i) U=betterUpper(U, uppers[i]); uppers={U};
        }
        if(!lowers.empty() && !uppers.empty()){
            int cmp=cmpVersion(lowers[0].second, uppers[0].second);
            // se lower > upper -> conflito
            if(cmp>0) return false;
            if(cmp==0){
                // só aceitável se operadores permitem igual
                bool allowEqLower = (lowers[0].first==">=");
                bool allowEqUpper = (uppers[0].first=="<=");
                if(!(allowEqLower && allowEqUpper)) return false;
            }
        }
    }
    return true;
}

// ========================= Receita =========================
struct Recipe{
    string path; map<string,string> kv; 
    vector<string> sources; vector<string> sha256; 
    vector<string> patches; vector<DepSpec> depends;
};

string trim(const string &s){ size_t a=s.find_first_not_of(" \t\r\n"); if(a==string::npos) return ""; size_t b=s.find_last_not_of(" \\t\r\n"); return s.substr(a,b-a+1);}

Recipe loadRecipe(const string &file){
    ifstream in(file); if(!in){ cerr<<C(ansi::red)<<"Erro abrindo receita: "<<file<<C(ansi::reset)<<"\n"; exit(1); }
    Recipe r; r.path=file; string line; 
    while(getline(in,line)){
        line=trim(line); if(line.empty()||line[0]=='#'||line[0]=='[') continue;
        auto eq=line.find('='); if(eq==string::npos) continue;
        string k=trim(line.substr(0,eq)); string v=trim(line.substr(eq+1));
        if(k.rfind("source",0)==0){ r.sources.push_back(v); }
        else if(k.rfind("sha256",0)==0){ r.sha256.push_back(v); }
        else if(k.rfind("patch",0)==0){ r.patches.push_back(v); }
        else if(k=="depends"||k=="deps"){
            // aceita separado por espaço e/ou vírgula
            string cur; stringstream ss(v); while(getline(ss, cur, ',')){
                stringstream ss2(cur); string tok; while(ss2>>tok){ auto d=parseDep(tok); if(!d.name.empty()) r.depends.push_back(d); }
            }
        } else r.kv[k]=v;
    }
    return r;
}
string recipeName(const Recipe &r){ auto it=r.kv.find("name"); return it==r.kv.end()?"":it->second; }
string recipeVersion(const Recipe &r){ auto it=r.kv.find("version"); return it==r.kv.end()?"":it->second; }
string workDir(const Recipe &r){ return joinPath(cfg.WORK, recipeName(r)+"-"+recipeVersion(r)); }
string buildDir(const Recipe &r){ string bd = r.kv.count("build_dir")? r.kv.at("build_dir"): string("."); return joinPath(workDir(r), bd); }
string pkgTar(const Recipe &r){ return joinPath(joinPath(cfg.PKG,"bin"), recipeName(r)+"-"+recipeVersion(r)+".tar.zst"); }
string dbDir(const Recipe &r){ return joinPath(cfg.DB, recipeName(r)); }
string manifestFilesPath(const Recipe &r){ return joinPath(dbDir(r), "manifest.files"); }
string manifestDirsPath(const Recipe &r){ return joinPath(dbDir(r), "manifest.dirs"); }
string metaPath(const Recipe &r){ return joinPath(dbDir(r), "meta"); }

// ========================= URL & formatos =========================
bool starts_with(const string&s,const string&p){ return s.rfind(p,0)==0; }
bool contains(const string&s,const string&x){ return s.find(x)!=string::npos; }

bool isGitUrl(const string &url){
    if(starts_with(url,"git://")||starts_with(url,"git@")) return true;
    if(starts_with(url,"https://")||starts_with(url,"http://")){
        if(contains(url,".git")) return true;
    }
    return false;
}

// ========================= SHA256 =========================
string sha256_file(const string& file){
    string cmd = "bash -lc 'sha256sum " + shellEscape(file) + " | awk \"{print $1}\"'";
    FILE* pipe=popen(cmd.c_str(),"r"); if(!pipe) return "";
    char buf[256]; string out; if(fgets(buf,sizeof(buf),pipe)) out=trim(buf); pclose(pipe); return out;
}
bool verifySha256(const string &file, const string &expected){
    if(expected.empty()) return true;
    string got=sha256_file(file);
    if(got.empty()) return false;
    if(got!=expected){
        cerr<<C(ansi::red)<<"SHA256 divergente: "<<file<<" esperado="<<expected<<" obtido="<<got<<C(ansi::reset)<<"\n";
        return false;
    }
    return true;
}

// ========================= Download & Extrair =========================
int fetchOne(const string &url, const string &out){
    if(isGitUrl(url)){
        return sh("git clone --depth 1 "+shellEscape(url)+" "+shellEscape(out));
    } else {
        return sh("curl -L --fail --retry 3 -o "+shellEscape(out)+" "+shellEscape(url));
    }
}

int extract(const string &archive, const string &dest){
    // tenta tar/bsdtar, unzip, 7z conforme extensão
    string a=archive;
    if(a.size()>4 && a.substr(a.size()-4)==".zip"){
        return sh("unzip -q "+shellEscape(a)+" -d "+shellEscape(dest));
    }
    if(contains(a,".tar.")) return sh("tar -xf "+shellEscape(a)+" -C "+shellEscape(dest));
    if(a.size()>3 && (a.substr(a.size()-3)==".xz" || a.substr(a.size()-3)==".gz" || a.substr(a.size()-3)==".bz2" )) 
        return sh("tar -xf "+shellEscape(a)+" -C "+shellEscape(dest));
    // fallback 7z
    return sh("7z x "+shellEscape(a)+" -o"+shellEscape(dest));
}

int downloadSources(const Recipe &r, string &outDir){
    // Limpa workdir anterior
    if(existsPath(workDir(r))) sh("rm -rf "+shellEscape(workDir(r)));
    ensureDir(workDir(r));
    Spinner sp; sp.start("Baixando/extraíndo fontes de "+recipeName(r));
    for(size_t i=0;i<r.sources.size();++i){
        string url=r.sources[i];
        if(isGitUrl(url)){
            string dest = joinPath(workDir(r), string("src")+to_string(i)); ensureDir(dest);
            int rc = sh("git clone --depth 1 "+shellEscape(url)+" "+shellEscape(dest));
            if(rc!=0){ sp.stopFail(); return rc; }
        } else {
            string cacheTarget = joinPath(cfg.CACHE, recipeName(r)+"-"+recipeVersion(r)+"-src"+to_string(i));
            int rc = fetchOne(url, cacheTarget); if(rc!=0){ sp.stopFail(); return rc; }
            string expected = (i<r.sha256.size()? r.sha256[i]: string(""));
            if(!verifySha256(cacheTarget, expected)){ sp.stopFail(); return 100; }
            rc = extract(cacheTarget, workDir(r)); if(rc!=0){ sp.stopFail(); return rc; }
        }
    }
    outDir = workDir(r);
    sp.stopOk();
    return 0;
}

// ========================= Patches =========================
int applyPatchFile(const string &patchPath, const string &dest){
    return sh("patch -p1 -d "+shellEscape(dest)+" < "+shellEscape(patchPath));
}

int applyPatches(const Recipe &r){
    string wd = workDir(r);
    Spinner sp; sp.start("Aplicando patches de "+recipeName(r));
    for(auto &p : r.patches){
        string path=p;
        if(starts_with(p,"http://")||starts_with(p,"https://")){
            string tmp = joinPath(cfg.CACHE, string("patch-")+to_string(hash<string>{}(p)));
            if(fetchOne(p,tmp)!=0){ sp.stopFail(); return 1; }
            if(applyPatchFile(tmp, wd)!=0){ sp.stopFail(); return 1; }
        } else if(isGitUrl(p)){
            string tmpdir = joinPath(cfg.CACHE, string("patchrepo-")+to_string(hash<string>{}(p))); 
            if(existsPath(tmpdir)) sh("rm -rf "+shellEscape(tmpdir)); ensureDir(tmpdir);
            if(sh("git clone --depth 1 "+shellEscape(p)+" "+shellEscape(tmpdir))!=0){ sp.stopFail(); return 1; }
            string cmd = "bash -lc 'shopt -s nullglob; for f in " + shellEscape(tmpdir) + "/*.patch; do patch -p1 -d " + shellEscape(wd) + " < \"$f\"; done'";
            if(sh(cmd)!=0){ sp.stopFail(); return 1; } 
        } else if(fs::is_directory(p)){
            string cmd = "bash -lc 'shopt -s nullglob; for f in " + shellEscape(p) + "/*.patch; do patch -p1 -d " + shellEscape(wd) + " < \"$f\"; done'";
            if(sh(cmd)!=0){ sp.stopFail(); return 1; }
        } else {
            if(applyPatchFile(path, wd)!=0){ sp.stopFail(); return 1; }
        }
    }
    // patches locais do diretório da receita
    string pdir = joinPath(fs::path(r.path).parent_path().string(), "patches");
    if(existsPath(pdir)){
        string cmd = "bash -lc 'shopt -s nullglob; for f in " + shellEscape(pdir) + "/*.patch; do patch -p1 -d " + shellEscape(wd) + " < \"$f\"; done'";
        if(sh(cmd)!=0){ sp.stopFail(); return 1; }
    }
    sp.stopOk();
    return 0;
}

// ========================= Hooks =========================
void runHook(const string &hook, const Recipe &r){
    string script = joinPath(joinPath(cfg.REPO, "hooks"), hook+".sh");
    if(existsPath(script)) {
        string cmd = "bash -lc '"+shellEscape(script)+" "+shellEscape(recipeName(r))+" "+shellEscape(recipeVersion(r))+"'";
        sh(cmd);
    }
}

// ========================= Build & Install =========================
int runBuildSystem(const Recipe &r){
    string bs = r.kv.count("build_system")? r.kv.at("build_system"):"autotools";
    string dir = buildDir(r);
    int jobs = g_jobs;

    if(r.kv.count("pre_build")){
        if(sh("bash -lc 'cd "+shellEscape(dir)+" && "+r.kv.at("pre_build")+"'" ) != 0) return 1;
    }
    if(r.kv.count("build")){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && "+r.kv.at("build")+"' ");
    }
    if(bs=="autotools"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && ./configure --prefix=/usr "+(r.kv.count("build_opts")?r.kv.at("build_opts"):string(""))+" && make -j"+to_string(jobs)+"' ");
    } else if(bs=="cmake"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && cmake -B build -S . -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr "+(r.kv.count("build_opts")?r.kv.at("build_opts"):string(""))+" && cmake --build build -j"+to_string(jobs)+"' ");
    } else if(bs=="meson"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && meson setup build --prefix=/usr "+(r.kv.count("build_opts")?r.kv.at("build_opts"):string(""))+" && meson compile -C build -j "+to_string(jobs)+"' ");
    }
    return 1;
}

int runInstall(const Recipe &r, const string &destdir){
    string bs = r.kv.count("build_system")? r.kv.at("build_system"):"autotools";
    string dir = buildDir(r);
    string prefix="";
    if(cfg.USE_FAKEROOT && haveCmd("fakeroot")) prefix="fakeroot ";

    if(r.kv.count("install")){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && "+prefix+"DESTDIR="+shellEscape(destdir)+" "+r.kv.at("install")+"' ");
    }
    if(bs=="autotools"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && "+prefix+"make DESTDIR="+shellEscape(destdir)+" install' ");
    } else if(bs=="cmake"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && "+prefix+"cmake --install build --prefix /usr --config Release --verbose' ");
    } else if(bs=="meson"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && "+prefix+"meson install -C build' ");
    }
    return 1;
}

// ========================= Manifesto, Pacote, DB =========================
int writeManifestFromDest(const Recipe &r, const string &destdir){
    string d = dbDir(r); ensureDir(d);
    // Arquivos
    {
        ofstream mf(manifestFilesPath(r)); if(!mf) return 1;
        string cmd = "bash -lc 'cd "+shellEscape(destdir)+" && find . -type f -o -type l | sed \"s#^\\./##\" | sort'";
        FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) return 1; char buf[4096];
        while(fgets(buf,sizeof(buf),pipe)){
            string rel=string(buf); rel.erase(remove(rel.begin(), rel.end(),'\n'), rel.end()); if(rel.empty()) continue; 
            mf << joinPath(cfg.DESTDIR, rel) << "\n"; 
        }
        pclose(pipe);
    }
    // Diretórios (profundo → raso)
    {
        ofstream md(manifestDirsPath(r)); if(!md) return 1;
        string cmd = "bash -lc 'cd "+shellEscape(destdir)+" && find . -type d | sed \"s#^\\./##\" | sort -r'";
        FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) return 1; char buf[4096];
        vector<string> dirs;
        while(fgets(buf,sizeof(buf),pipe)){
            string rel=string(buf); rel.erase(remove(rel.begin(), rel.end(),'\n'), rel.end()); if(rel==".") continue; 
            dirs.push_back(joinPath(cfg.DESTDIR, rel));
        }
        pclose(pipe);
        for(auto &d: dirs) md<<d<<"\n";
    }
    // Meta
    {
        ofstream meta(metaPath(r));
        meta << "name="<<recipeName(r)<<"\n";
        meta << "version="<<recipeVersion(r)<<"\n";
        meta << "install_time="<<timestamp()<<"\n";
        // deps (apenas nomes)
        meta << "deps=";
        for(size_t i=0;i<r.depends.size();++i){
            meta<<r.depends[i].name<<(i+1<r.depends.size()?",":"");
        }
        meta << "\n";
    }
    return 0;
}

int makePkgFromDest(const Recipe &r, const string &destdir){
    string pkg = pkgTar(r);
    ensureDir(fs::path(pkg).parent_path().string());
    string cmd = "bash -lc 'cd "+shellEscape(destdir)+" && tar -I zstd -cf "+shellEscape(pkg)+" .'";
    return sh(cmd);
}

int installPkgToRoot(const Recipe &r, const string &pkg){
    string root = cfg.DESTDIR;
    return sh("tar -I zstd -xf "+shellEscape(pkg)+" -C "+shellEscape(root));
}

// instala de binário se existir e escreve manifesto a partir da lista do tar
bool installFromBinaryIfAvailable(const Recipe &r){
    string pkg = pkgTar(r);
    if(!existsPath(pkg)) return false;
    Spinner sp; sp.start("Instalando binário "+fs::path(pkg).filename().string());
    int rc = installPkgToRoot(r, pkg);
    if(rc!=0){ sp.stopFail(); return false; }
    // gerar manifesto a partir do conteúdo do tar
    string tmpList = joinPath(cfg.CACHE, "list-"+to_string(hash<string>{}(pkg)));
    string cmd = "bash -lc 'tar -I zstd -tf "+shellEscape(pkg)+" | sort > "+shellEscape(tmpList)+"'";
    if(sh(cmd)!=0){ sp.stopFail(); return false; }
    // criar manifest.* com base na lista
    ensureDir(dbDir(r));
    {
        ofstream mf(manifestFilesPath(r));
        ifstream in(tmpList); string line;
        vector<string> dirs;
        while(getline(in,line)){
            if(line.empty()) continue;
            if(line.back()=='/') { // diretório
                string full = joinPath(cfg.DESTDIR, line.substr(0, line.size()-1));
                dirs.push_back(full);
            } else {
                mf<<joinPath(cfg.DESTDIR, line)<<"\n";
            }
        }
        in.close();
        ofstream md(manifestDirsPath(r));
        sort(dirs.rbegin(), dirs.rend());
        for(auto &d: dirs) if(d!="/") md<<d<<"\n";
    }
    // meta
    ofstream meta(metaPath(r));
    meta << "name="<<recipeName(r)<<"\n";
    meta << "version="<<recipeVersion(r)<<"\n";
    meta << "install_time="<<timestamp()<<"\n";
    meta << "deps=";
    for(size_t i=0;i<r.depends.size();++i){ meta<<r.depends[i].name<<(i+1<r.depends.size()?",":""); }
    meta << "\n";
    sp.stopOk();
    return true;
}

// ========================= Buscar receitas =========================
vector<string> findRecipesByName(const string &query){
    vector<string> found; 
    for(const string &cat: {"base","x11","extras","desktop"}){
        string cdir = joinPath(cfg.REPO, cat);
        string cmd = "bash -lc 'shopt -s globstar nullglob; for f in " + shellEscape(cdir) + "/**/*.fbuild; do echo \"$f\"; done'";
        FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) continue; char buf[4096];
        while(fgets(buf,sizeof(buf),pipe)){
            string p=trim(buf); if(p.empty()) continue; 
            string base=fs::path(p).filename().string();
            if(query.empty() || base.find(query)!=string::npos) found.push_back(p);
        }
        pclose(pipe);
    }
    return found;
}

// ========================= Resolução de dependências =========================
struct NodeReq { string pkg; vector<pair<string,string>> cons; }; // pkg + restrições acumuladas

// carrega receita por nome lógico (procura nas categorias)
string findRecipeFileByPkg(const string& pkg){
    // procura por "<cat>/<pkg>-*/<pkg>-*.fbuild"
    for(const string &cat: {"base","x11","extras","desktop"}){
        string cdir = joinPath(cfg.REPO, cat);
        for(auto &p: fs::recursive_directory_iterator(cdir)){
            if(!p.is_regular_file()) continue;
            if(p.path().extension()==".fbuild"){
                // abre e checa name
                Recipe r=loadRecipe(p.path().string());
                if(recipeName(r)==pkg) return p.path().string();
            }
        }
    }
    return "";
}

Recipe loadRecipeByName(const string &pkg){
    string f=findRecipeFileByPkg(pkg);
    if(f.empty()){ cerr<<C(ansi::red)<<"Receita não encontrada para "<<pkg<<C(ansi::reset)<<"\n"; exit(1); }
    return loadRecipe(f);
}

bool isInstalledSatisfying(const string& pkg, const vector<pair<string,string>>& cons){
    string d = joinPath(cfg.DB, pkg);
    string m = joinPath(d,"meta");
    if(!existsPath(m)) return false;
    ifstream in(m); string line; string ver;
    while(getline(in,line)){ if(line.rfind("version=",0)==0){ ver=trim(line.substr(8)); break; } }
    if(ver.empty()) return false;
    return satisfies(ver, cons);
}

// retorna ordem topológica + conflito detectado
vector<Recipe> resolvePlan(const Recipe &root){
    // BFS/DFS com acumulação de restrições por pacote
    unordered_map<string, vector<pair<string,string>>> need; // pkg -> constraints
    unordered_map<string, set<string>> edges;
    vector<string> order; // topo depois

    function<void(const Recipe&)> dfs = [&](const Recipe& r){
        string name=recipeName(r);
        if(!need.count(name)) need[name] = {};
        // adiciona deps
        for(const auto& d : r.depends){
            // merge constraints
            auto &acc = need[d.name];
            vector<pair<string,string>> tmp=acc;
            if(!mergeConstraints(tmp, d.constraints)){
                cerr<<C(ansi::red)<<"Conflito de versão em "<<d.name<<" requerido por "<<name<<C(ansi::reset)<<"\n";
                exit(1);
            }
            acc=tmp;
            edges[recipeName(r)].insert(d.name);
            // dfs recursivo
            Recipe dr = loadRecipeByName(d.name);
            dfs(dr);
        }
    };
    dfs(root);

    // Kahn topo sort
    unordered_map<string,int> indeg;
    for(auto &kv: edges){ for(auto &to: kv.second) indeg[to]++; if(!indeg.count(kv.first)) indeg[kv.first]=0; }
    vector<string> zero;
    for(auto &kv: indeg) if(kv.second==0) zero.push_back(kv.first);
    // se root não aparecer, garanta inclusão
    if(!edges.count(recipeName(root)) && !indeg.count(recipeName(root))) zero.push_back(recipeName(root));

    while(!zero.empty()){
        string u=zero.back(); zero.pop_back();
        order.push_back(u);
        if(edges.count(u)){
            for(auto &v: edges[u]){
                if(--indeg[v]==0) zero.push_back(v);
            }
        }
    }
    // construir vetor Recipe na ordem (deps antes do alvo)
    vector<Recipe> plan;
    // remover duplicatas mantendo ordem
    unordered_set<string> seen;
    for(const string &pkg : order){
        if(seen.insert(pkg).second){
            string f=findRecipeFileByPkg(pkg);
            if(!f.empty()) plan.push_back(loadRecipe(f));
        }
    }
    // garante que root esteja por último
    if(plan.empty() || recipeName(plan.back())!=recipeName(root)){
        plan.push_back(root);
    }
    return plan;
}

// ========================= Ações =========================
int action_sync(){
    if(!existsPath(joinPath(cfg.REPO, ".git"))){
        cerr<<C(ansi::yellow)<<"Aviso: REPO não é um repositório git. Pulando."<<C(ansi::reset)<<"\n";
        return 0;
    }
    Spinner sp; sp.start("Sincronizando repositório");
    int rc = sh("git -C "+shellEscape(cfg.REPO)+" pull --ff-only");
    if(rc==0) sp.stopOk(); else sp.stopFail();
    return rc;
}

int action_new(const vector<string>&args){
    if(args.size()<2){ cerr<<"Uso: fbuild new <categoria> <nome> <versão>\n"; return 1; }
    string cat=args[0]; string name=args[1]; string ver=args.size()>=3?args[2]:"1.0";
    string dir = joinPath(joinPath(cfg.REPO, cat), name+"-"+ver);
    ensureDir(dir);
    string file = joinPath(dir, name+"-"+ver+".fbuild");
    ofstream f(file);
    f << "# Receita fbuild\n";
    f << "name="<<name<<"\nversion="<<ver<<"\nsummary=\nlicense=\nhomepage=\n";
    f << "source0=\n# sha2560=\n# patch0=\n";
    f << "build_system=autotools\n# build_opts=\n# pre_build=\n# build=\n# install=\n# build_dir=.\n# depends=\n";
    cout<<file<<" criado.\n";
    return 0;
}

int action_search(const vector<string>&args){
    string q = args.size()? args[0]: string("");
    for(auto &p: findRecipesByName(q)) cout<<p<<"\n"; 
    return 0; 
}

int action_info(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild info <arquivo .fbuild>\n"; return 1; }
    Recipe r=loadRecipe(args[0]);
    cout<<C(ansi::bold)<<recipeName(r)<<" "<<recipeVersion(r)<<C(ansi::reset)<<"\n";
    for(auto &kv: r.kv) cout<<kv.first<<"="<<kv.second<<"\n";
    for(size_t i=0;i<r.sources.size();++i) cout<<"source"<<i<<"="<<r.sources[i]<<"\n";
    for(size_t i=0;i<r.patches.size();++i) cout<<"patch"<<i<<"="<<r.patches[i]<<"\n";
    for(size_t i=0;i<r.sha256.size();++i) cout<<"sha256"<<i<<"="<<r.sha256[i]<<"\n";
    return 0;
}

int action_download(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild download <.fbuild>\n"; return 1; } 
    Recipe r=loadRecipe(args[0]);
    runHook("pre-download", r); string out; int rc=downloadSources(r,out); runHook("post-download", r); return rc; 
}

int action_unpack(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild unpack <.fbuild>\n"; return 1; } 
    Recipe r=loadRecipe(args[0]);
    runHook("pre-download", r); string out; if(downloadSources(r,out)!=0) return 1; runHook("post-download", r); 
    runHook("pre-patch", r); int rc=applyPatches(r); runHook("post-patch", r); return rc; 
}

int action_patch(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild patch <.fbuild>\n"; return 1; } 
    Recipe r=loadRecipe(args[0]); runHook("pre-patch", r); int rc=applyPatches(r); runHook("post-patch", r); return rc; 
}

int action_build(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild build <.fbuild>\n"; return 1; }
    requireCmds({"bash","git","curl","tar","patch"});
    Recipe r=loadRecipe(args[0]);
    runHook("pre-download", r); string out; if(downloadSources(r,out)!=0) return 1; runHook("post-download", r);
    runHook("pre-patch", r); if(applyPatches(r)!=0) return 1; runHook("post-patch", r);
    runHook("pre-build", r); int rc=runBuildSystem(r); if(rc!=0) return rc; runHook("post-build", r);
    return 0;
}

int action_install(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild install <.fbuild|nome>\n"; return 1; }
    requireCmds({"bash","git","curl","tar","patch","sha256sum","zstd"});
    // Aceita caminho .fbuild ou nome lógico
    Recipe r = (fs::path(args[0]).extension()==".fbuild")? loadRecipe(args[0]): loadRecipeByName(args[0]);

    // Resolução de dependências com restrições e ordem topológica
    vector<Recipe> plan = resolvePlan(r);
    for(const auto& pr : plan){
        // Se instalado e satisfaz, pula
        if(isInstalledSatisfying(recipeName(pr), {})){ 
            // se existe restrição acumulada? Para simplificar, sempre checar meta
            string m=joinPath(joinPath(cfg.DB,recipeName(pr)),"meta");
            ifstream in(m); string line, ver; while(getline(in,line)){ if(line.rfind("version=",0)==0) ver=trim(line.substr(8)); }
            // se já igual ao recipe, pula; senão, tenta upgrade
            if(ver==recipeVersion(pr)){ if(!g_quiet) cerr<<"• "<<recipeName(pr)<<" já instalado ("<<ver<<")\n"; continue; }
        }

        // tenta instalar de binário primeiro
        if(installFromBinaryIfAvailable(pr)){
            if(!g_quiet) cerr<<"• "<<recipeName(pr)<<" instalado via binário\n";
            continue;
        }

        // Fase de download/patch/build/install em DESTDIR
        string log = actionLog(recipeName(pr), "install");

        runHook("pre-download", pr); string out; if(downloadSources(pr,out)!=0){ cerr<<"download falhou\n"; return 1; } runHook("post-download", pr);
        runHook("pre-patch", pr); if(applyPatches(pr)!=0){ cerr<<"patch falhou\n"; return 1; } runHook("post-patch", pr);
        runHook("pre-build", pr); if(runBuildSystem(pr)!=0){ cerr<<"build falhou\n"; return 1; } runHook("post-build", pr);

        string tmpdest = joinPath(cfg.WORK, string("dest-")+recipeName(pr)+"-"+recipeVersion(pr));
        if(existsPath(tmpdest)) sh("rm -rf "+shellEscape(tmpdest)); ensureDir(tmpdest);

        runHook("pre-install", pr);
        if(runInstall(pr, tmpdest)!=0) { cerr<<"install (fase em DESTDIR) falhou\n"; sh("rm -rf "+shellEscape(tmpdest)); return 1; }

        if(writeManifestFromDest(pr, tmpdest)!=0) cerr<<C(ansi::yellow)<<"Aviso: não foi possível gerar manifesto"<<C(ansi::reset)<<"\n";
        if(makePkgFromDest(pr, tmpdest)!=0) { cerr<<"empacotamento falhou\n"; return 1; }

        if(installPkgToRoot(pr, pkgTar(pr))!=0) { cerr<<"instalação no root falhou\n"; return 1; }
        runHook("post-install", pr);

        cout<<C(ansi::green)<<"Instalado: "<<recipeName(pr)<<"-"<<recipeVersion(pr)<<C(ansi::reset)<<"\n";
        sh("rm -rf "+shellEscape(tmpdest));
    }
    return 0;
}

int action_remove(const vector<string>&args, bool force){
    if(args.empty()){ cerr<<"Uso: fbuild remove <nome>\n"; return 1; }
    string name=args[0];
    // checar dependentes
    for(auto &p: fs::directory_iterator(cfg.DB)){
        if(!p.is_directory()) continue;
        string depmeta = joinPath(p.path().string(),"meta");
        ifstream in(depmeta); if(!in) continue; string line; 
        while(getline(in,line)){
            if(line.rfind("deps=",0)==0){
                string deps=line.substr(5); string tok; stringstream ss(deps);
                while(getline(ss,tok,',')){ if(trim(tok)==name){ 
                    if(!force){ cerr<<C(ansi::red)<<"Não é possível remover "<<name<<": requerido por "<<p.path().filename().string()<<C(ansi::reset)<<"\n"; return 2; }
                } }
            }
        }
    }

    // carrega meta para hooks
    Recipe dummy; dummy.kv["name"]=name; dummy.kv["version"]="unknown";
    string d=joinPath(cfg.DB,name);
    string meta=joinPath(d,"meta");
    ifstream mi(meta); if(mi){ string line; while(getline(mi,line)){ if(line.rfind("version=",0)==0) dummy.kv["version"]=trim(line.substr(8)); } }

    runHook("pre-remove", dummy);

    string mfpath = joinPath(d,"manifest.files");
    string mdpath = joinPath(d,"manifest.dirs");

    // Remoção de arquivos listados
    ifstream mf(mfpath);
    if(mf){
        vector<string> files; string path;
        while(getline(mf,path)){ path=trim(path); if(!path.empty()) files.push_back(path); }
        // Remove arquivos primeiro (e links)
        for(auto it=files.rbegin(); it!=files.rend(); ++it){
            string cmd = "bash -lc 'if [ -e " + shellEscape(*it) + " ] || [ -L " + shellEscape(*it) + " ]; then rm -f " + shellEscape(*it) + "; fi'";
            sh(cmd);
        }
    } else {
        cerr<<C(ansi::yellow)<<"Aviso: manifest.files ausente; não é possível remover arquivos"<<C(ansi::reset)<<"\n";
    }

    // Remoção de diretórios *apenas* os listados (profundo → raso)
    ifstream md(mdpath);
    if(md){
        vector<string> dirs; string path; while(getline(md,path)){ path=trim(path); if(!path.empty()) dirs.push_back(path); }
        for(auto &dir: dirs){ string cmd = "bash -lc 'if [ -d " + shellEscape(dir) + " ] && [ -z \"$(ls -A " + shellEscape(dir) + ")\" ]; then rmdir " + shellEscape(dir) + "; fi'"; sh(cmd); }
    } else {
        cerr<<C(ansi::yellow)<<"Aviso: manifest.dirs ausente; diretórios não foram removidos"<<C(ansi::reset)<<"\n";
    }

    // apaga db
    if(existsPath(d)) sh("rm -rf "+shellEscape(d));
    runHook("post-remove", dummy);
    cout<<C(ansi::yellow)<<"Removido (arquivos/diretórios listados): "<<name<<C(ansi::reset)<<"\n";
    return 0;
}

int action_upgrade(){
    // percorre todos os pacotes instalados e compara com receita
    for(auto &p: fs::directory_iterator(cfg.DB)){
        if(!p.is_directory()) continue;
        string name=p.path().filename().string();
        string meta=joinPath(p.path().string(),"meta");
        string installedVer; ifstream in(meta); string line;
        while(getline(in,line)){ if(line.rfind("version=",0)==0) installedVer=trim(line.substr(8)); }
        if(installedVer.empty()) continue;
        // achar receita
        string rf=findRecipeFileByPkg(name); if(rf.empty()) continue;
        Recipe r=loadRecipe(rf);
        if(cmpVersion(recipeVersion(r), installedVer)>0){
            cerr<<"Upgrade "<<name<<" "<<installedVer<<" → "<<recipeVersion(r)<<"\n";
            // tenta binário
            if(!installFromBinaryIfAvailable(r)){
                // compila
                vector<string> a = {rf};
                int rc = action_install(a);
                if(rc!=0) return rc;
            }
        }
    }
    return 0;
}

int action_clean(){ sh("rm -rf "+shellEscape(cfg.WORK)); ensureDir(cfg.WORK); cout<<"WORK limpo.\n"; return 0; }
int action_revdep(){ cout<<"revdep: análise simplificada ainda não implementada.\n"; return 0; }
int action_orphans(){ cout<<"orphans: análise simplificada ainda não implementada.\n"; return 0; }

// ========================= Ajuda =========================
void help(const char* argv0){
    cout<<"fbuild - gerenciador source->bin (com DESTDIR/fakeroot, SHA256, patches, hooks, deps)\n\n";
    cout<<"Variáveis (export): REPO, FB_CACHE, FB_WORK, FB_PKG, FB_DB, FB_LOG, DESTDIR, FB_USE_FAKEROOT\n";
    cout<<"Flags globais: -jN/--jobs N, -y/--yes, -q/--quiet, -v/--verbose, --no-color\n";
    cout<<"Atalhos CLI: install|in, build|bi, remove|rm, download|dl\n\n";
    cout<<"Comandos:\n";
    cout<<"  init-repo                         # cria estrutura $REPO/{base,x11,extras,desktop}\n";
    cout<<"  new <categoria> <nome> <ver>      # cria pasta e receita .fbuild\n";
    cout<<"  sync                              # git pull no REPO\n";
    cout<<"  search [termo]                    # procura receitas\n";
    cout<<"  info <arquivo.fbuild>             # mostra metadados\n";
    cout<<"  download|dl <arquivo.fbuild>      # baixa fontes (com SHA256 opcional)\n";
    cout<<"  unpack <arquivo.fbuild>           # baixa + descompacta + aplica patches\n";
    cout<<"  patch <arquivo.fbuild>            # aplica patches (se já extraído)\n";
    cout<<"  build|bi <arquivo.fbuild>         # compila sem instalar\n";
    cout<<"  install|in <arquivo.fbuild|nome>  # resolve deps, empacota e instala\n";
    cout<<"  remove|rm <nome> [--force]        # remove via manifest.files/.dirs (checa dependentes)\n";
    cout<<"  upgrade                           # tenta atualizar pacotes instalados\n";
    cout<<"  revdep                            # stub\n";
    cout<<"  orphans                           # stub\n";
    cout<<"  clean                             # limpa WORK\n";
    cout<<"  help                              # esta ajuda\n\n";
}

// ========================= main =========================
int main(int argc, char **argv){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // parse flags globais simples
    vector<string> args; args.reserve(argc);
    for(int i=1;i<argc;i++){
        string a=argv[i];
        if(a=="-h"||a=="--help"){ help(argv[0]); return 0; }
        else if(a=="--no-color"){ g_no_color=true; }
        else if(a=="-q"||a=="--quiet"){ g_quiet=true; g_verbose=false; }
        else if(a=="-v"||a=="--verbose"){ g_quiet=false; g_verbose=true; }
        else if(a=="-y"||a=="--yes"){ g_yes=true; }
        else if(starts_with(a,"-j")){ 
            string n = (a=="-j" && i+1<argc)? string(argv[++i]) : (a.size()>2? a.substr(2): ""); 
            if(!n.empty()) g_jobs=max(1, stoi(n));
        }
        else if(a=="--jobs" && i+1<argc){ g_jobs=max(1, stoi(argv[++i])); }
        else if(a=="--destdir" && i+1<argc){ cfg.DESTDIR=argv[++i]; }
        else if(a=="--pkgdir" && i+1<argc){ cfg.PKG=argv[++i]; ensureDir(cfg.PKG); ensureDir(joinPath(cfg.PKG,"bin")); }
        else if(a=="--workdir" && i+1<argc){ cfg.WORK=argv[++i]; ensureDir(cfg.WORK); }
        else if(a=="--cachedir" && i+1<argc){ cfg.CACHE=argv[++i]; ensureDir(cfg.CACHE); }
        else { args.push_back(a); }
    }

    if(getenv("NO_COLOR")) g_no_color=true; 
    ensureBaseDirs();

    if(args.empty()){ help(argv[0]); return 0; }
    string cmd=args[0];
    vector<string> rest(args.begin()+1, args.end());

    // comandos e atalhos
    if(cmd=="help") { help(argv[0]); return 0; }
    if(cmd=="init-repo"||cmd=="init") { ensureBaseDirs(); cout<<"Estrutura criada em "<<cfg.REPO<<"\n"; return 0; }
    if(cmd=="sync") return action_sync();
    if(cmd=="new") return action_new(rest);
    if(cmd=="search") return action_search(rest);
    if(cmd=="info") return action_info(rest);
    if(cmd=="download"||cmd=="dl") return action_download(rest);
    if(cmd=="unpack") return action_unpack(rest);
    if(cmd=="patch") return action_patch(rest);
    if(cmd=="build"||cmd=="bi") return action_build(rest);
    if(cmd=="install"||cmd=="in") return action_install(rest);
    if(cmd=="remove"||cmd=="rm") { bool force=false; if(!rest.empty() && rest.back()=="--force"){ force=true; rest.pop_back(); } return action_remove(rest, force); }
    if(cmd=="upgrade") return action_upgrade();
    if(cmd=="clean") return action_clean();
    if(cmd=="revdep") return action_revdep();
    if(cmd=="orphans") return action_orphans();

    cerr<<C(ansi::red)<<"Comando desconhecido: "<<cmd<<C(ansi::reset)<<"\n";
    help(argv[0]);
    return 1;
}
