// fbuild - Gerenciador de programas source-based + binários para LFS
// Linguagem: C++17
// Compilação: g++ -std=c++17 -O2 -pthread -o fbuild main.cpp
// Dependências (runtime): bash, git, curl, tar, unzip, xz, 7z, patch, zstd, sha256sum, (opcional) fakeroot
//
// Recursos principais:
//  - CLI com subcomandos: init-repo, new, sync, search, info, build, install, remove, upgrade, list, orphans, clean, help
//  - Flags: -y/--yes, --no-color, --quiet, -j/--jobs, -C/--config, --root, --repo, --cache, --work, --pkg, --db, --log, --pkgroot, --binfmt
//  - Resolução de dependências (topológica + detecção de ciclo), evita reinstalar o que já está ok
//  - Download de fontes via curl e git (com cache), extração direta para diretório de trabalho
//  - Patches via https (arquivos), git (repositórios de patches) e diretórios locais (.patch); aplicação automática
//  - Build via autotools, cmake, meson, ou comandos custom do recipe
//  - Instalação via DESTDIR isolado -> empacotamento binário .fbuildpkg -> instalação real a partir do binário
//  - Confere SHA256 de fontes e de pacotes binários (.fbuildpkg)
//  - Hooks (globais e locais por receita): pre/post download, patch, build, install, remove
//  - Manifesto de arquivos e diretórios instalados; remoção segura apenas do listado e diretórios vazios
//  - Banco simples de instalados com reverse-deps; não remove dependência se houver pacotes dependentes
//  - Spinner e logs por ação; suporte a múltiplos repositórios (básico), sync (git pull)
//  - Upgrade: reinstala se versão do recipe for diferente/maior
//
// Observações de segurança:
//  - Para simplicidade, utiliza system()/bash -lc com escapes. Em produção, considere spawn/execve.
//  - fakeroot é usado apenas no empacotamento; instalação final no root de destino pode requerer privilégios.
//
// ========================= INCLUDES =========================
#include <bits/stdc++.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <filesystem>

using namespace std;
namespace fs = std::filesystem;

// ========================= ANSI / UX =========================
namespace ansi {
    const string reset  = "\033[0m";
    const string bold   = "\033[1m";
    const string dim    = "\033[2m";
    const string red    = "\033[31m";
    const string green  = "\033[32m";
    const string yellow = "\033[33m";
    const string blue   = "\033[34m";
    const string magenta= "\033[35m";
    const string cyan   = "\033[36m";
    const string gray   = "\033[90m";
}

static bool verbose = true;
static bool no_color = false;
static bool assume_yes = false;
static int  global_jobs = max(1u, thread::hardware_concurrency());
static string global_binfmt = "zst"; // formato de compressão do .fbuildpkg: zst ou gz

string C(const string &color){ return no_color? string("") : color; }

// ========================= Helpers gerais =========================
string shellEscape(const string &s){
    string out; out.reserve(s.size()*2);
    for(unsigned char c: s){
        if(isalnum(c) || c=='/'||c=='_'||c=='.'||c=='-'||c=='+') out.push_back(c);
        else { out.push_back('\\'); out.push_back(c); }
    }
    return out;
}

bool existsPath(const string &p){ return access(p.c_str(), F_OK)==0; }

string getenvs(const string &k, const string &def=""){ const char* v=getenv(k.c_str()); return v? string(v):def; }

string joinPath(const string &a, const string &b){ if(a.empty()) return b; if(a.back()=='/') return a+b; return a+"/"+b; }

string timestamp(){ time_t t=time(nullptr); char buf[64]; strftime(buf,64,"%Y-%m-%d_%H-%M-%S",localtime(&t)); return buf; }

void ensureDir(const string &p){ if(!existsPath(p)) { if(mkdir(p.c_str(), 0755)!=0){ perror(("mkdir "+p).c_str()); exit(1);} } }

// executar comando (opcionalmente logando em arquivo)
int sh(const string &cmd, const string &logfile=""){
    if(verbose) cerr << C(ansi::gray) << "→ " << cmd << C(ansi::reset) << "\n";
    if(!logfile.empty()){
        string real = "bash -lc '" + cmd + "' >>" + shellEscape(logfile) + " 2>&1";
        return system(real.c_str());
    }
    return system(cmd.c_str());
}

// ler saída de comando (1a linha)
string shOut1(const string &cmd){
    string c = "bash -lc '"+cmd+"'";
    FILE* pipe=popen(c.c_str(),"r"); if(!pipe) return "";
    char buf[4096]; string out;
    if(fgets(buf,sizeof(buf),pipe)) out = string(buf);
    pclose(pipe);
    // trim
    while(!out.empty() && (out.back()=='\n'||out.back()=='\r')) out.pop_back();
    return out;
}

// Verifica se binário está no PATH
bool haveCmd(const string &cmd){ string c = "bash -lc 'command -v "+shellEscape(cmd)+" >/dev/null'"; return system(c.c_str())==0; }

void requireCmds(const vector<string>&cmds){
    vector<string> missing;
    for(auto &c:cmds){ if(!haveCmd(c)) missing.push_back(c); }
    if(!missing.empty()){
        cerr<<C(ansi::red)<<"Faltam dependências no PATH: ";
        for(size_t i=0;i<missing.size();++i){ cerr<<missing[i]<<(i+1<missing.size()?", ":""); }
        cerr<<C(ansi::reset)<<"\n"; exit(2);
    }
}

// Spinner simples
class Spinner {
    atomic<bool> running{false};
    thread th; string msg;
public:
    void start(const string &m){ msg=m; running=true; th=thread([&]{
        const char* frames="|/-\\"; int i=0;
        while(running){ cerr << "\r" << C(ansi::cyan) << frames[i++%4] << C(ansi::reset) << " " << msg << "   "; cerr.flush(); this_thread::sleep_for(chrono::milliseconds(100)); }
        cerr << "\r" << string(msg.size()+8,' ') << "\r"; cerr.flush();
    }); }
    void stopOk(){ running=false; if(th.joinable()) th.join(); cerr << C(ansi::green) << "✔" << C(ansi::reset) << " " << msg << "\n"; }
    void stopFail(){ running=false; if(th.joinable()) th.join(); cerr << C(ansi::red) << "✖" << C(ansi::reset) << " " << msg << "\n"; }
};

// ========================= Configuração =========================
struct Config{
    // Diretórios principais (padrões podem ser sobrescritos por env/flags)
    string REPO   = getenvs("REPO", string(getenvs("HOME"))+"/fbuild-repo");
    string CACHE  = getenvs("FB_CACHE", string(getenvs("HOME"))+"/.cache/fbuild");
    string WORK   = getenvs("FB_WORK",  string(getenvs("HOME"))+"/.local/share/fbuild/work");
    string PKG    = getenvs("FB_PKG",   string(getenvs("HOME"))+"/.local/share/fbuild/pkg"); // legacy (manifest local)
    string DB     = getenvs("FB_DB",    string(getenvs("HOME"))+"/.local/share/fbuild/db");
    string LOG    = getenvs("FB_LOG",   string(getenvs("HOME"))+"/.local/share/fbuild/log");
    string DESTROOT = getenvs("DESTDIR", "/"); // raiz alvo final (instalação real)

    // Raiz onde ficam os binários .fbuildpkg (cache binário)
    string PKGROOT = getenvs("FBUILD_PKGROOT", string(getenvs("HOME"))+"/.local/share/fbuild/pkgroot"); // bin/
    // Raiz de build DESTDIR dos pacotes (árvore ROOT simulada)
    string BUILDROOT = getenvs("FBUILD_BUILDROOT", string(getenvs("HOME"))+"/.local/share/fbuild/buildroot");
} cfg;

void ensureBaseDirs(){
    for(auto &d: {cfg.REPO, cfg.CACHE, cfg.WORK, cfg.PKG, cfg.DB, cfg.LOG, cfg.PKGROOT, cfg.BUILDROOT}) ensureDir(d);
    for(auto &sub: {string("base"),string("x11"),string("extras"),string("desktop"),string("hooks")}) ensureDir(joinPath(cfg.REPO, sub));
    ensureDir(joinPath(cfg.PKGROOT,"bin")); // onde ficam os .fbuildpkg
}

// ========================= Formato de receita =========================
struct Recipe{
    string path;
    map<string,string> kv;
    vector<string> sources;
    vector<string> sha256;
    vector<string> patches;
    vector<string> depends;
};

string trim(const string &s){ size_t a=s.find_first_not_of(" \t\r\n"); if(a==string::npos) return ""; size_t b=s.find_last_not_of(" \t\r\n"); return s.substr(a,b-a+1);}    

bool isGitUrl(const string &url){
    if(url.rfind("git://",0)==0) return true;
    if(url.rfind("git@",0)==0) return true;
    if(url.rfind("https://",0)==0 || url.rfind("http://",0)==0){
        if(url.size()>4 && url.find(".git")!=string::npos) return true;
    }
    return false;
}

Recipe loadRecipe(const string &file){
    ifstream in(file); if(!in) { cerr<<C(ansi::red)<<"Erro abrindo receita: "<<file<<C(ansi::reset)<<"\n"; exit(1);}    
    Recipe r; r.path=file; string line; 
    while(getline(in,line)){
        line=trim(line); if(line.empty()||line[0]=='#'||line[0]=='[') continue;
        auto eq=line.find('='); if(eq==string::npos) continue; string k=trim(line.substr(0,eq)); string v=trim(line.substr(eq+1));
        if(k.rfind("source",0)==0){ r.sources.push_back(v); }
        else if(k.rfind("sha256",0)==0){ r.sha256.push_back(v); }
        else if(k.rfind("patch",0)==0){ r.patches.push_back(v); }
        else if(k=="depends"){ stringstream ss(v); string x; while(ss>>x) r.depends.push_back(x); }
        else r.kv[k]=v;
    }
    return r;
}

string recipeName(const Recipe &r){ auto it=r.kv.find("name"); return it==r.kv.end()?"":it->second; }
string recipeVersion(const Recipe &r){ auto it=r.kv.find("version"); return it==r.kv.end()?"":it->second; }
string recipeBuildSys(const Recipe &r){ auto it=r.kv.find("build_system"); return it==r.kv.end()?"autotools":it->second; }
string workDir(const Recipe &r){ return joinPath(cfg.WORK, recipeName(r)+"-"+recipeVersion(r)); }
string buildDir(const Recipe &r){ string bd = r.kv.count("build_dir")? r.kv.at("build_dir"): string("."); return joinPath(workDir(r), bd); }
string pkgTarPath(const Recipe &r){ // pacote binário local (apenas nome base sugerido)
    string arch = shOut1("uname -m");
    string pkgname = recipeName(r)+"-"+recipeVersion(r)+"-"+arch+".fbuildpkg";
    return joinPath(joinPath(cfg.PKGROOT,"bin"), pkgname);
}
string dbDir(const Recipe &r){ return joinPath(cfg.DB, recipeName(r)); }
string manifestFilesPath(const Recipe &r){ return joinPath(dbDir(r), "manifest.files"); }
string manifestDirsPath(const Recipe &r){ return joinPath(dbDir(r), "manifest.dirs"); }
string metaPath(const Recipe &r){ return joinPath(dbDir(r), "meta"); }
string reverseDepsPath(){ return joinPath(cfg.DB, "_reverse_deps"); } // formato simples: dep -> [list of rdeps]

// ========================= SHA256 =========================
bool verifySha256File(const string &file, const string &expected){
    if(expected.empty()) return true;
    string cmd = "sha256sum " + shellEscape(file) + " | awk '{print $1}'";
    string got = shOut1(cmd);
    if(got.empty()) return false;
    if(got!=expected){
        cerr<<C(ansi::red)<<"SHA256 divergente: esperado="<<expected<<" obtido="<<got<<C(ansi::reset)<<"\n";
        return false;
    }
    return true;
}

string sha256OfFile(const string &file){
    string cmd = "sha256sum " + shellEscape(file) + " | awk '{print $1}'";
    return shOut1(cmd);
}

// ========================= Download & Extração =========================
int fetchOne(const string &url, const string &out){
    if(isGitUrl(url)){
        return sh("git clone --depth 1 "+shellEscape(url)+" "+shellEscape(out));
    } else {
        return sh("curl -L --fail --retry 3 -o "+shellEscape(out)+" "+shellEscape(url));
    }
}

int extractTo(const string &archive, const string &dest){
    string a=archive; 
    // zip
    if(a.size()>4 && a.substr(a.size()-4)==".zip") return sh("unzip -q "+shellEscape(a)+" -d "+shellEscape(dest));
    // tar.* (xz, gz, bz2, zst)
    if(a.find(".tar.")!=string::npos) return sh("tar -xf "+shellEscape(a)+" -C "+shellEscape(dest));
    // plain .xz / .gz (assumimos tar comprimido)
    if(a.size()>3 && (a.substr(a.size()-3)==".xz" || a.substr(a.size()-3)==".gz" || a.substr(a.size()-3)==".bz2")) return sh("tar -xf "+shellEscape(a)+" -C "+shellEscape(dest));
    // fallback 7z
    return sh("7z x "+shellEscape(a)+" -o"+shellEscape(dest));
}

int downloadSources(const Recipe &r, string &outDir){
    // Limpa workdir anterior
    if(existsPath(workDir(r))) sh("rm -rf "+shellEscape(workDir(r)));
    ensureDir(workDir(r));

    for(size_t i=0;i<r.sources.size();++i){
        string url=r.sources[i];
        if(isGitUrl(url)){
            string dest = joinPath(workDir(r), string("src")+to_string(i)); ensureDir(dest);
            int rc = sh("git clone --depth 1 "+shellEscape(url)+" "+shellEscape(dest));
            if(rc!=0) return rc;
        } else {
            string cacheTarget = joinPath(cfg.CACHE, recipeName(r)+"-"+recipeVersion(r)+"-src"+to_string(i));
            int rc = fetchOne(url, cacheTarget); if(rc!=0) return rc;
            string expected = (i<r.sha256.size()? r.sha256[i]: string(""));
            if(!verifySha256File(cacheTarget, expected)) return 100; // checksum errado
            rc = extractTo(cacheTarget, workDir(r)); if(rc!=0) return rc;
        }
    }
    outDir = workDir(r);
    return 0;
}

// Aplicação de patches (https, git, diretório local, arquivo local)
int applyPatchFile(const string &patchPath, const string &dest){
    return sh("patch -p1 -d "+shellEscape(dest)+" < "+shellEscape(patchPath));
}

int applyPatches(const Recipe &r){
    string wd = workDir(r);
    // patches declarados
    for(auto &p : r.patches){
        string path=p;
        if(p.rfind("http://",0)==0 || p.rfind("https://",0)==0){
            string tmp = joinPath(cfg.CACHE, string("patch-")+to_string(hash<string>{}(p)));
            if(fetchOne(p,tmp)!=0) return 1; path=tmp;
            if(applyPatchFile(path, wd)!=0) return 1;
        } else if(isGitUrl(p)){
            string tmpdir = joinPath(cfg.CACHE, string("patchrepo-")+to_string(hash<string>{}(p))); if(existsPath(tmpdir)) sh("rm -rf "+shellEscape(tmpdir)); ensureDir(tmpdir);
            if(sh("git clone --depth 1 "+shellEscape(p)+" "+shellEscape(tmpdir))!=0) return 1;
            string cmd = "bash -lc 'shopt -s nullglob; for f in " + shellEscape(tmpdir) + "/*.patch; do patch -p1 -d " + shellEscape(wd) + " < \"$f\"; done'";
            if(sh(cmd)!=0) return 1; 
        } else {
            // arquivo local individual
            if(fs::is_regular_file(path)){
                if(applyPatchFile(path, wd)!=0) return 1;
            } else if(fs::is_directory(path)){
                // diretório local de patches
                string cmd = "bash -lc 'shopt -s nullglob; for f in " + shellEscape(path) + "/*.patch; do patch -p1 -d " + shellEscape(wd) + " < \"$f\"; done'";
                if(sh(cmd)!=0) return 1;
            } else {
                cerr<<C(ansi::yellow)<<"Aviso: patch não encontrado: "<<path<<C(ansi::reset)<<"\n";
                return 1;
            }
        }
    }
    // patches locais do diretório da receita (./patches/*.patch)
    string pdir = joinPath(fs::path(r.path).parent_path().string(), "patches");
    if(existsPath(pdir)){
        string cmd = "bash -lc 'shopt -s nullglob; for f in " + shellEscape(pdir) + "/*.patch; do patch -p1 -d " + shellEscape(wd) + " < \"$f\"; done'";
        if(sh(cmd)!=0) return 1;
    }
    return 0;
}

// ========================= Hooks =========================
// Hooks globais: $REPO/hooks/<hook>.sh
// Hooks locais por receita: <dir_da_receita>/hooks/<hook>.sh
// Hooks suportados: pre-download, post-download, pre-patch, post-patch, pre-build, post-build, pre-install, post-install, pre-remove, post-remove
void runHook(const string &hook, const Recipe &r){
    vector<string> candidates;
    candidates.push_back(joinPath(joinPath(cfg.REPO,"hooks"), hook+".sh"));
    candidates.push_back(joinPath(joinPath(fs::path(r.path).parent_path().string(),"hooks"), hook+".sh"));

    for(const string &script: candidates){
        if(existsPath(script)) {
            string cmd = "bash -lc '"+shellEscape(script)+" "+shellEscape(recipeName(r))+" "+shellEscape(recipeVersion(r))+"'";
            sh(cmd);
        }
    }
}

// ========================= Build & Install (DESTDIR) =========================
int runBuildSystem(const Recipe &r){
    string bs = recipeBuildSys(r);
    string dir = buildDir(r);
    int jobs = global_jobs;

    if(r.kv.count("pre_build")){
        if(sh("bash -lc 'cd "+shellEscape(dir)+" && "+r.kv.at("pre_build")+"'" ) != 0) return 1;
    }
    if(r.kv.count("build")){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && "+r.kv.at("build")+"' ");
    }
    if(bs=="autotools"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && ./configure --prefix=/usr "+(r.kv.count("build_opts")?r.kv.at("build_opts"):string(""))+" && make -j"+to_string(jobs)+"' ");
    } else if(bs=="cmake"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && cmake -B build -S . -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr "+(r.kv.count("build_opts")?r.kv.at("build_opts"):string(""))+" && cmake --build build -j"+to_string(jobs)+"' ");
    } else if(bs=="meson"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && meson setup build --prefix=/usr "+(r.kv.count("build_opts")?r.kv.at("build_opts"):string(""))+" && meson compile -C build' ");
    }
    return 1;
}

int runInstallDestdir(const Recipe &r, const string &destroot){
    string bs = recipeBuildSys(r);
    string dir = buildDir(r);
    if(r.kv.count("install")){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && DESTDIR="+shellEscape(destroot)+" "+r.kv.at("install")+"' ");
    }
    if(bs=="autotools"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && make DESTDIR="+shellEscape(destroot)+" install' ");
    } else if(bs=="cmake"){
        // cmake --install respeita CMAKE_INSTALL_PREFIX, DESTDIR via env, mas passamos via env
        return sh("bash -lc 'cd "+shellEscape(dir)+" && DESTDIR="+shellEscape(destroot)+" cmake --install build --prefix /usr --config Release --verbose' ");
    } else if(bs=="meson"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && DESTDIR="+shellEscape(destroot)+" meson install -C build' ");
    }
    return 1;
}

// ========================= DB & Logs =========================
void dbRegister(const Recipe &r, const vector<string>&deps){
    string d=dbDir(r); ensureDir(d);
    ofstream meta(metaPath(r));
    meta << "name="<<recipeName(r)<<"\n";
    meta << "version="<<recipeVersion(r)<<"\n";
    meta << "install_time="<<timestamp()<<"\n";
    meta << "depends=";
    for(size_t i=0;i<deps.size();++i){ meta<<deps[i]<<(i+1<deps.size()?" ":""); }
    meta << "\n";
}

void dbUnregister(const string &name){
    string d=joinPath(cfg.DB, name);
    if(existsPath(d)) sh("rm -rf "+shellEscape(d));
}

string actionLog(const string &name,const string &action){ return joinPath(cfg.LOG, name+"-"+action+"-"+timestamp()+".log"); }

map<string,set<string>> loadReverseDeps(){
    map<string,set<string>> rd;
    string f=reverseDepsPath();
    ifstream in(f);
    string a,b;
    while(in>>a>>b){
        rd[a].insert(b); // a <- b (b depende de a)
    }
    return rd;
}

void saveReverseDeps(const map<string,set<string>>&rd){
    string f=reverseDepsPath();
    ofstream out(f);
    for(auto &kv: rd){
        for(auto &who: kv.second){
            out<<kv.first<<" "<<who<<"\n";
        }
    }
}

void reverseDepsAdd(const string &dep, const string &who){
    auto rd = loadReverseDeps();
    rd[dep].insert(who);
    saveReverseDeps(rd);
}

void reverseDepsRemove(const string &dep, const string &who){
    auto rd = loadReverseDeps();
    if(rd.count(dep)){ rd[dep].erase(who); if(rd[dep].empty()) rd.erase(dep); }
    saveReverseDeps(rd);
}

set<string> reverseDepsOf(const string &pkg){
    auto rd = loadReverseDeps();
    if(rd.count(pkg)) return rd[pkg];
    return {};
}

bool isInstalled(const string &name, string *versionOut=nullptr){
    string d=joinPath(cfg.DB, name);
    string meta=joinPath(d,"meta");
    ifstream in(meta);
    if(!in) return false;
    string line; string ver;
    while(getline(in,line)){
        if(line.rfind("version=",0)==0){ ver=trim(line.substr(8)); break; }
    }
    if(versionOut) *versionOut = ver;
    return true;
}

// ========================= Empacotamento & Manifesto =========================
int writeManifestFromDest(const Recipe &r, const string &destroot){
    string d = dbDir(r); ensureDir(d);
    // Arquivos
    {
        ofstream mf(manifestFilesPath(r)); if(!mf) return 1;
        string cmd = "bash -lc 'cd "+shellEscape(destroot)+" && find . -type f -o -type l | sed \"s#^\\./##\" | sort'";
        FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) return 1; char buf[4096];
        while(fgets(buf,sizeof(buf),pipe)){
            string rel=string(buf); rel.erase(remove(rel.begin(), rel.end(),'\n'), rel.end()); if(rel.empty()) continue; 
            mf << joinPath(cfg.DESTROOT, rel) << "\n"; 
        }
        pclose(pipe);
    }
    // Diretórios
    {
        ofstream md(manifestDirsPath(r)); if(!md) return 1;
        string cmd = "bash -lc 'cd "+shellEscape(destroot)+" && find . -type d | sed \"s#^\\./##\" | sort -r'";
        FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) return 1; char buf[4096];
        vector<string> dirs;
        while(fgets(buf,sizeof(buf),pipe)){
            string rel=string(buf); rel.erase(remove(rel.begin(), rel.end(),'\n'), rel.end()); if(rel==".") continue; 
            dirs.push_back(joinPath(cfg.DESTROOT, rel));
        }
        pclose(pipe);
        for(auto &d: dirs) md<<d<<"\n";
    }
    return 0;
}

string buildRootFor(const Recipe &r){
    return joinPath(cfg.BUILDROOT, recipeName(r)+"-"+recipeVersion(r));
}

int makeBinaryPackage(const Recipe &r, const string &destroot, string &outPkgPath){
    // cria tar do conteúdo de destroot com meta + sha256
    string arch = shOut1("uname -m");
    string base = recipeName(r)+"-"+recipeVersion(r)+"-"+arch+".fbuildpkg";
    string pkg = joinPath(joinPath(cfg.PKGROOT,"bin"), base);

    // preparar staging temp (para incluir meta)
    string staging = joinPath(cfg.WORK, string("stage-")+recipeName(r)+"-"+recipeVersion(r));
    if(existsPath(staging)) sh("rm -rf "+shellEscape(staging));
    ensureDir(staging);

    // copiar a raiz (conteúdo) para staging/root/
    ensureDir(joinPath(staging,"root"));
    // Usamos tar pipeline para preservar links/perms; se houver fakeroot, não precisamos copiar, mas para embutir meta fica simples copiar.
    // Usar rsync seria melhor, mas manteremos tar | tar:
    string copyCmd = "bash -lc 'cd "+shellEscape(destroot)+" && tar -cf - . | (cd "+shellEscape(joinPath(staging,"root"))+" && tar -xf -)'";
    if(sh(copyCmd)!=0) return 1;

    // meta simples (key=value)
    string metaFile = joinPath(staging,"meta");
    {
        ofstream m(metaFile);
        m << "name="<<recipeName(r)<<"\n";
        m << "version="<<recipeVersion(r)<<"\n";
        m << "arch="<<arch<<"\n";
        // dependências (usar r.depends)
        m << "depends=";
        for(size_t i=0;i<r.depends.size();++i) m<<r.depends[i]<<(i+1<r.depends.size()?" ":"");
        m << "\n";
        m << "built_at="<<timestamp()<<"\n";
        m << "build_system="<<recipeBuildSys(r)<<"\n";
    }

    // criar pacote .fbuildpkg (tar -I zstd/gzip)
    string comp = (global_binfmt=="gz")? "gzip -c" : "zstd -19 -T0";
    string suffix = (global_binfmt=="gz")? ".tar.gz" : ".tar.zst";
    // Para manter extensão .fbuildpkg, mas compactar com comp adequado
    // Vamos criar tar sem extensão e depois mover.
    string tmpTar = joinPath(cfg.WORK, string("binpkg-")+to_string(rand())+".tar");
    string tarCmd  = "bash -lc 'cd "+shellEscape(staging)+" && tar -cf "+shellEscape(tmpTar)+" .'";
    if(sh(tarCmd)!=0) return 1;

    string outTmp = tmpTar + (global_binfmt=="gz"?".gz":".zst");
    string compCmd = "bash -lc '"+comp+" < "+shellEscape(tmpTar)+" > "+shellEscape(outTmp)+"'";
    if(haveCmd("fakeroot")){
        // compressão não precisa fakeroot; conteúdo já possui perms do destroot. Se quisesse simular dono root:root na criação do tar,
        // teríamos que gerar tar dentro de fakeroot. Para simplicidade, aceitamos assim.
        // (opcional) poderíamos refazer empacotamento com: fakeroot sh -lc 'cd staging && tar ...'
    }
    if(sh(compCmd)!=0) return 1;

    // Calcular sha256 do pacote comprimido e armazenar em arquivo .sha256 (ao lado do .fbuildpkg)
    string hash = sha256OfFile(outTmp);

    // mover/renomear para .fbuildpkg
    if(existsPath(pkg)) sh("rm -f "+shellEscape(pkg));
    if(sh("mv "+shellEscape(outTmp)+" "+shellEscape(pkg))!=0) return 1;

    string shaFile = pkg + ".sha256";
    ofstream s(shaFile); s<<hash<<"\n";

    // limpeza staging e tmpTar
    sh("rm -f "+shellEscape(tmpTar));
    sh("rm -rf "+shellEscape(staging));

    outPkgPath = pkg;
    return 0;
}

int installPkgToRootFS(const Recipe &r, const string &pkg){
    // Verificar SHA do pacote se existir .sha256 junto
    string shaFile = pkg + ".sha256";
    if(existsPath(shaFile)){
        ifstream in(shaFile); string expect; getline(in,expect); expect=trim(expect);
        if(!verifySha256File(pkg, expect)){ cerr<<C(ansi::red)<<"SHA256 do pacote binário divergente"<<C(ansi::reset)<<"\n"; return 1; }
    }
    // Extrair no root real (cfg.DESTROOT)
    string cmd = "bash -lc 'tar -I "+string(global_binfmt=="gz"?"gzip":"zstd")+" -xf "+shellEscape(pkg)+" -C "+shellEscape(cfg.DESTROOT)+"'";
    // O pacote contém: ./root/... e ./meta; precisamos extrair **apenas root** no destino final.
    // Para manter simples: extraímos tudo num tmp, depois movemos root/* para DESTROOT/
    string tmp = joinPath(cfg.WORK, string("installpkg-")+recipeName(r)+"-"+recipeVersion(r));
    if(existsPath(tmp)) sh("rm -rf "+shellEscape(tmp));
    ensureDir(tmp);

    string extractCmd = "bash -lc 'tar -I "+string(global_binfmt=="gz"?"gzip":"zstd")+" -xf "+shellEscape(pkg)+" -C "+shellEscape(tmp)+"'";
    if(sh(extractCmd)!=0) return 1;

    // mover root/* para DESTROOT/
    string moveCmd = "bash -lc 'cd "+shellEscape(joinPath(tmp,"root"))+" && tar -cf - . | (cd "+shellEscape(cfg.DESTROOT)+" && tar -xf -)'";
    if(sh(moveCmd)!=0) return 1;

    // limpeza
    sh("rm -rf "+shellEscape(tmp));
    return 0;
}

// ========================= Busca/Receitas =========================
vector<string> findRecipesFiles(const string &query="", bool onlyExact=false){
    vector<string> found; 
    for(const string &cat: {"base","x11","extras","desktop"}){
        string cdir = joinPath(cfg.REPO, cat);
        string cmd = "bash -lc 'shopt -s globstar nullglob; for f in " + shellEscape(cdir) + "/**/*.fbuild; do echo \"$f\"; done'";
        FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) continue; char buf[4096];
        while(fgets(buf,sizeof(buf),pipe)){
            string p=trim(buf); if(p.empty()) continue; 
            if(query.empty()){
                found.push_back(p);
            } else {
                string base=fs::path(p).filename().string();
                if(onlyExact){
                    if(base==query || base.find(query)!=string::npos) found.push_back(p);
                }else{
                    if(base.find(query)!=string::npos) found.push_back(p);
                }
            }
        }
        pclose(pipe);
    }
    sort(found.begin(), found.end());
    return found;
}

string findRecipeByNamePreferExact(const string &name){
    // procura por arquivo .../<name>-<ver>.fbuild preferindo match prefixo
    auto all = findRecipesFiles(name);
    for(auto &p: all){
        string fname = fs::path(p).filename().string();
        if(fname.rfind(name,0)==0 && fname.find(".fbuild")!=string::npos) return p;
    }
    // fallback 1o
    if(!all.empty()) return all[0];
    return "";
}

// ========================= Resolução de dependências =========================
struct Node {
    string name;
    string file;
    vector<string> deps;
};

map<string,Node> loadAllNodesForTargets(const vector<string>&targets){
    map<string,Node> nodes;
    // carregar recipe de cada alvo e seus deps
    deque<string> q(targets.begin(), targets.end());
    set<string> visited;
    while(!q.empty()){
        string t = q.front(); q.pop_front();
        if(visited.count(t)) continue; visited.insert(t);
        string rf = findRecipeByNamePreferExact(t);
        if(rf.empty()){ cerr<<C(ansi::red)<<"Receita não encontrada para "<<t<<C(ansi::reset)<<"\n"; exit(1); }
        Recipe r = loadRecipe(rf);
        Node n; n.name = recipeName(r); n.file = rf; n.deps = r.depends;
        nodes[n.name]=n;
        for(auto &d: r.depends) q.push_back(d);
    }
    return nodes;
}

vector<string> topoSort(const map<string,Node>&graph){
    // Kahn
    map<string,int> indeg;
    for(auto &kv: graph){ indeg[kv.first]=0; }
    for(auto &kv: graph){
        for(auto &d: kv.second.deps){
            if(indeg.count(d)==0) indeg[d]=0;
            indeg[kv.first]++;
        }
    }
    deque<string> q;
    for(auto &kv: indeg) if(kv.second==0) q.push_back(kv.first);
    vector<string> order;
    while(!q.empty()){
        string u=q.front(); q.pop_front();
        order.push_back(u);
        for(auto &kv: graph){
            if(find(kv.second.deps.begin(), kv.second.deps.end(), u)!=kv.second.deps.end()){
                if(--indeg[kv.first]==0) q.push_back(kv.first);
            }
        }
    }
    if(order.size()!=graph.size()){
        cerr<<C(ansi::red)<<"Ciclo de dependência detectado!"<<C(ansi::reset)<<"\n";
        exit(1);
    }
    return order;
}

// ========================= Ações =========================
int action_sync(const vector<string>&){
    if(!existsPath(joinPath(cfg.REPO, ".git"))){
        cerr<<C(ansi::yellow)<<"Aviso: REPO não é um repositório git. Pulando."<<C(ansi::reset)<<"\n";
        return 0;
    }
    Spinner sp; sp.start("Sincronizando repositório");
    int rc = sh("git -C "+shellEscape(cfg.REPO)+" pull --ff-only");
    if(rc==0) sp.stopOk(); else sp.stopFail();
    return rc;
}

int action_new(const vector<string>&args){
    if(args.size()<2){ cerr<<"Uso: fbuild new <categoria> <nome> <versão>\n"; return 1; }
    string cat=args[0]; string name=args[1]; string ver=args.size()>=3?args[2]:"1.0";
    string dir = joinPath(joinPath(cfg.REPO, cat), name+"-"+ver);
    ensureDir(dir);
    string file = joinPath(dir, name+"-"+ver+".fbuild");
    ofstream f(file);
    f << "# Exemplo de receita fbuild\n";
    f << "name="<<name<<"\nversion="<<ver<<"\nsummary=\nlicense=\nhomepage=\n";
    f << "source0=\n# sha2560=\n# patch0=\n";
    f << "build_system=autotools\n# build_opts=\n# pre_build=\n# build=\n# install=\n# build_dir=.\n# depends=\n";
    cout<<file<<" criado.\n";
    return 0;
}

int action_search(const vector<string>&args){ string q = args.size()? args[0]: string(""); for(auto &p: findRecipesFiles(q)) cout<<p<<"\n"; return 0; }

int action_info(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild info <arquivo .fbuild>\n"; return 1; }
    Recipe r=loadRecipe(args[0]);
    cout<<C(ansi::bold)<<recipeName(r)<<" "<<recipeVersion(r)<<C(ansi::reset)<<"\n";
    for(auto &kv: r.kv) cout<<kv.first<<"="<<kv.second<<"\n";
    for(size_t i=0;i<r.sources.size();++i) cout<<"source"<<i<<"="<<r.sources[i]<<"\n";
    for(size_t i=0;i<r.patches.size();++i) cout<<"patch"<<i<<"="<<r.patches[i]<<"\n";
    for(size_t i=0;i<r.sha256.size();++i) cout<<"sha256"<<i<<"="<<r.sha256[i]<<"\n";
    for(size_t i=0;i<r.depends.size();++i) cout<<"depends+"<<i<<"="<<r.depends[i]<<"\n";
    return 0;
}

int do_build_only(const Recipe &r){
    requireCmds({"bash","git","curl","tar","patch"});
    runHook("pre-download", r);
    string out; if(downloadSources(r,out)!=0) { cerr<<"download falhou\n"; return 1; }
    runHook("post-download", r);

    runHook("pre-patch", r);
    if(applyPatches(r)!=0) { cerr<<"patch falhou\n"; return 1; }
    runHook("post-patch", r);

    runHook("pre-build", r);
    if(runBuildSystem(r)!=0) { cerr<<"build falhou\n"; return 1; }
    runHook("post-build", r);

    return 0;
}

int action_build(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild build <.fbuild>\n"; return 1; }
    Recipe r=loadRecipe(args[0]);
    return do_build_only(r);
}

// Instala a partir do binário (se existir). Se não, compila, empacota e instala.
int install_with_binary_or_source(Recipe r, const vector<string>&depChain){
    requireCmds({"bash","git","curl","tar","patch","sha256sum"});
    if(global_binfmt=="zst") requireCmds({"zstd"});
    else requireCmds({"gzip"});

    string log = actionLog(recipeName(r), "install");

    // Tenta binário primeiro
    string binpkg = pkgTarPath(r);
    if(existsPath(binpkg)){
        Spinner sp; sp.start("Instalando binário "+fs::path(binpkg).filename().string());
        if(installPkgToRootFS(r, binpkg)!=0){ sp.stopFail(); cerr<<"instalação do binário falhou; tentando compilar do source\n"; }
        else {
            sp.stopOk();
            // registrar DB e manifest a partir do pacote já instalado
            // Para capturar o manifesto, não temos destroot; então não sabemos lista de arquivos. Opcionalmente, podemos montar um destroot temporário:
            // Estratégia: não refazer manifesto aqui (seria caro). Em vez disso, construir um "manifest" aproximando do pacote (não temos índice). 
            // Solução prática: durante empacotar, já salvamos manfestos no DB? Preferimos gerar manifesto quando empacotamos.
            // Como pode ter sido feito por outra máquina, aqui geramos manifesto através de "pkg verify": NÃO temos. Então aceitamos sem manifesto (limitação).
            // Para resolver: após instalar, rodar "find" para capturar alterações é arriscado. Manteremos aviso:
            cerr<<C(ansi::yellow)<<"Aviso: pacote binário instalado sem manifesto local. Recomenda-se instalar uma vez via fonte nesta máquina para manifestos precisos.\n"<<C(ansi::reset);
            dbRegister(r, r.depends);
            for(auto &d: r.depends) reverseDepsAdd(d, recipeName(r));
            cout<<C(ansi::green)<<"Instalado (binário): "<<recipeName(r)<<"-"<<recipeVersion(r)<<C(ansi::reset)<<"\n";
            return 0;
        }
    }

    // Caminho por fonte: baixar, patch, build, DESTDIR, empacotar, instalar
    runHook("pre-download", r); string out; if(downloadSources(r,out)!=0) { cerr<<"download falhou\n"; return 1; } runHook("post-download", r);
    runHook("pre-patch", r); if(applyPatches(r)!=0) { cerr<<"patch falhou\n"; return 1; } runHook("post-patch", r);
    runHook("pre-build", r); if(runBuildSystem(r)!=0) { cerr<<"build falhou\n"; return 1; } runHook("post-build", r);

    // DESTDIR isolado
    string destroot = buildRootFor(r);
    if(existsPath(destroot)) sh("rm -rf "+shellEscape(destroot));
    ensureDir(destroot);

    runHook("pre-install", r);
    if(runInstallDestdir(r, destroot)!=0) { cerr<<"install (em DESTDIR) falhou\n"; sh("rm -rf "+shellEscape(destroot)); return 1; }

    // Manifesto
    if(writeManifestFromDest(r, destroot)!=0) cerr<<C(ansi::yellow)<<"Aviso: não foi possível gerar manifesto"<<C(ansi::reset)<<"\n";

    // Empacotar
    string outpkg;
    if(makeBinaryPackage(r, destroot, outpkg)!=0) { cerr<<"empacotamento falhou\n"; return 1; }

    // Instalar o binário recém-criado
    if(installPkgToRootFS(r, outpkg)!=0) { cerr<<"instalação do pacote binário falhou\n"; return 1; }
    runHook("post-install", r);

    dbRegister(r, r.depends);
    for(auto &d: r.depends) reverseDepsAdd(d, recipeName(r));
    cout<<C(ansi::green)<<"Instalado: "<<recipeName(r)<<"-"<<recipeVersion(r)<<C(ansi::reset)<<"\n";

    // limpeza
    sh("rm -rf "+shellEscape(destroot));
    return 0;
}

int action_install(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild install <arquivo.fbuild|nome>\n"; return 1; }

    // Se arg parece arquivo, usa direto; senão, resolve recipe
    string path = args[0];
    Recipe r;
    if(fs::exists(path)) r = loadRecipe(path);
    else {
        string rf = findRecipeByNamePreferExact(path);
        if(rf.empty()){ cerr<<C(ansi::red)<<"Receita não encontrada: "<<path<<C(ansi::reset)<<"\n"; return 1; }
        r = loadRecipe(rf);
    }

    // Resolver dependências (topo) e instalar na ordem
    auto nodes = loadAllNodesForTargets({recipeName(r)});
    auto order = topoSort(nodes);

    // Instalar deps primeiro (exceto o alvo se aparecer no meio)
    for(const string &pkg : order){
        string rf = nodes[pkg].file;
        Recipe rr = loadRecipe(rf);
        if(pkg==recipeName(r)) continue; // deixa alvo por último
        string installedVer;
        if(isInstalled(pkg, &installedVer)){
            // já instalado; pula (futuro: comparar versão)
            continue;
        }
        if(install_with_binary_or_source(rr, rr.depends)!=0) return 1;
    }
    // Agora o alvo
    string installedVer;
    if(isInstalled(recipeName(r), &installedVer)){
        cout<<C(ansi::yellow)<<"Já instalado: "<<recipeName(r)<<" "<<installedVer<<C(ansi::reset)<<"\n";
        return 0;
    }
    return install_with_binary_or_source(r, r.depends);
}

int action_remove(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild remove <nome>\n"; return 1; }
    string name=args[0];

    // Checar reverse-deps
    auto rdeps = reverseDepsOf(name);
    if(!rdeps.empty()){
        cerr<<C(ansi::red)<<"Não é seguro remover "<<name<<": outros pacotes dependem dele: ";
        size_t i=0; for(auto &x: rdeps){ cerr<<x<<((++i<rdeps.size())?", ":""); }
        cerr<<C(ansi::reset)<<"\n";
        return 1;
    }

    // Recupera versão do DB para hooks
    Recipe dummy; dummy.kv["name"]=name; dummy.kv["version"]="unknown";
    string d=joinPath(cfg.DB,name);
    string meta=joinPath(d,"meta");
    ifstream mi(meta); if(mi){ string line; while(getline(mi,line)){ if(line.rfind("version=",0)==0) dummy.kv["version"]=trim(line.substr(8)); if(line.rfind("depends=",0)==0){ string rest=trim(line.substr(8)); stringstream ss(rest); string t; while(ss>>t) dummy.depends.push_back(t); } } }

    runHook("pre-remove", dummy);

    string mfpath = joinPath(d,"manifest.files");
    string mdpath = joinPath(d,"manifest.dirs");

    // Remoção de arquivos listados
    ifstream mf(mfpath);
    if(mf){
        vector<string> files; string path;
        while(getline(mf,path)){ path=trim(path); if(!path.empty()) files.push_back(path); }
        for(auto it=files.rbegin(); it!=files.rend(); ++it){
            string cmd = "bash -lc 'if [ -e " + shellEscape(*it) + " ] || [ -L " + shellEscape(*it) + " ]; then rm -f " + shellEscape(*it) + "; fi'";
            sh(cmd);
        }
    } else {
        cerr<<C(ansi::yellow)<<"Aviso: manifest.files ausente; não é possível remover arquivos com precisão"<<C(ansi::reset)<<"\n";
    }

    // Remoção de diretórios *apenas* os listados (profundo → raso)
    ifstream md(mdpath);
    if(md){
        vector<string> dirs; string path; while(getline(md,path)){ path=trim(path); if(!path.empty()) dirs.push_back(path); }
        for(auto &dir: dirs){ string cmd = "bash -lc 'if [ -d " + shellEscape(dir) + " ] && [ -z \"$(ls -A " + shellEscape(dir) + ")\" ]; then rmdir " + shellEscape(dir) + "; fi'"; sh(cmd); }
    } else {
        cerr<<C(ansi::yellow)<<"Aviso: manifest.dirs ausente; diretórios não foram removidos"<<C(ansi::reset)<<"\n";
    }

    // Remover reverse-deps registros
    for(auto &dname: dummy.depends) reverseDepsRemove(dname, name);

    dbUnregister(name);
    runHook("post-remove", dummy);
    cout<<C(ansi::yellow)<<"Removido: "<<name<<C(ansi::reset)<<"\n";
    return 0;
}

int action_upgrade(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild upgrade <arquivo.fbuild|nome>\n"; return 1; }
    string arg=args[0];
    Recipe r;
    if(fs::exists(arg)) r=loadRecipe(arg);
    else {
        string rf = findRecipeByNamePreferExact(arg);
        if(rf.empty()){ cerr<<C(ansi::red)<<"Receita não encontrada: "<<arg<<C(ansi::reset)<<"\n"; return 1; }
        r=loadRecipe(rf);
    }
    string curVer;
    if(!isInstalled(recipeName(r), &curVer)){
        cout<<"Não instalado. Instalando.\n";
        return install_with_binary_or_source(r, r.depends);
    }
    if(curVer==recipeVersion(r)){
        cout<<C(ansi::yellow)<<"Já na versão mais recente: "<<recipeName(r)<<" "<<curVer<<C(ansi::reset)<<"\n";
        return 0;
    }
    cout<<"Atualizando "<<recipeName(r)<<" de "<<curVer<<" para "<<recipeVersion(r)<<"\n";
    // Estratégia simples: instalar nova (vai sobrescrever arquivos). Manifesto antigo permanece para remoção futura.
    return install_with_binary_or_source(r, r.depends);
}

int action_list(const vector<string>&){
    // Lista pacotes instalados
    for(auto &entry : fs::directory_iterator(cfg.DB)){
        if(!entry.is_directory()) continue;
        string meta = joinPath(entry.path().string(), "meta");
        ifstream in(meta); if(!in) continue;
        string name=entry.path().filename().string(), ver="unknown";
        string line; while(getline(in,line)){ if(line.rfind("version=",0)==0){ ver=trim(line.substr(8)); break; } }
        cout<<name<<" "<<ver<<"\n";
    }
    return 0;
}

int action_orphans(const vector<string>&){
    // órfãos = instalados que não são dependência de ninguém
    auto rd = loadReverseDeps();
    for(auto &entry : fs::directory_iterator(cfg.DB)){
        if(!entry.is_directory()) continue;
        string name=entry.path().filename().string();
        if(name=="_reverse_deps") continue;
        if(rd.find(name)==rd.end() || rd[name].empty()){
            cout<<name<<"\n";
        }
    }
    return 0;
}

int action_clean(const vector<string>&){
    sh("rm -rf "+shellEscape(cfg.WORK));
    ensureDir(cfg.WORK);
    cout<<"WORK limpo.\n";
    return 0;
}

void help(){
    cout<<"fbuild - gerenciador source+bin (DESTDIR, binários .fbuildpkg, sha256, hooks)\n\n";
    cout<<"Variáveis (export): REPO, FB_CACHE, FB_WORK, FB_PKG, FB_DB, FB_LOG, DESTDIR, FBUILD_PKGROOT, FBUILD_BUILDROOT\n\n";
    cout<<"Flags globais:\n";
    cout<<"  -y, --yes                auto-yes em prompts\n";
    cout<<"  --no-color               desabilita cores\n";
    cout<<"  --quiet                  menos saída\n";
    cout<<"  -j, --jobs N             paralelismo de build (default: núcleos)\n";
    cout<<"  -C, --config <path>      (reservado)\n";
    cout<<"  --root <dir>             raiz final (DESTDIR real) para instalar (default: /)\n";
    cout<<"  --repo <dir>             path do repositório de receitas\n";
    cout<<"  --cache <dir>            cache de fontes\n";
    cout<<"  --work <dir>             diretório de trabalho (sources extraídos)\n";
    cout<<"  --db <dir>               banco de instalados\n";
    cout<<"  --log <dir>              logs\n";
    cout<<"  --pkgroot <dir>          raiz de pacotes binários (.fbuildpkg)\n";
    cout<<"  --buildroot <dir>        raiz DESTDIR dos builds\n";
    cout<<"  --binfmt <zst|gz>        compressão dos pacotes binários (default: zst)\n";
    cout<<"\nComandos:\n";
    cout<<"  init-repo                         # cria estrutura $REPO/{base,x11,extras,desktop}\n";
    cout<<"  new <categoria> <nome> <ver>      # cria pasta e receita .fbuild\n";
    cout<<"  sync                              # git pull no REPO\n";
    cout<<"  search [termo]                    # procura receitas\n";
    cout<<"  info <arquivo.fbuild>             # mostra metadados\n";
    cout<<"  build <arquivo.fbuild>            # compila (sem instalar)\n";
    cout<<"  install <arquivo.fbuild|nome>     # instala (binário se existir; senão compila)\n";
    cout<<"  remove <nome>                     # remove via manifest.files/.dirs; checa reverse-deps\n";
    cout<<"  upgrade <arquivo.fbuild|nome>     # reinstala se versão nova\n";
    cout<<"  list                               # lista pacotes instalados\n";
    cout<<"  orphans                            # lista pacotes sem dependentes\n";
    cout<<"  clean                              # limpa WORK\n";
    cout<<"  help                               # esta ajuda\n\n";
}

// ========================= init-repo =========================
int action_init_repo(const vector<string>&){ ensureBaseDirs(); cout<<"Estrutura criada em "<<cfg.REPO<<"\n"; return 0; }

// ========================= CLI parsing =========================
struct Argv {
    string cmd;
    vector<string> args;
};

Argv parseArgs(int argc, char **argv){
    Argv a;
    for(int i=1;i<argc;i++){
        string s=argv[i];
        if(s=="-y"||s=="--yes"){ assume_yes=true; continue; }
        if(s=="--no-color"){ no_color=true; continue; }
        if(s=="--quiet"){ verbose=false; continue; }
        if(s=="-j"||s=="--jobs"){ if(i+1<argc){ global_jobs=stoi(argv[++i]); } continue; }
        if(s=="-C"||s=="--config"){ if(i+1<argc){ /* reservado */ ++i; } continue; }
        if(s=="--root"){ if(i+1<argc){ cfg.DESTROOT=argv[++i]; ensureDir(cfg.DESTROOT); } continue; }
        if(s=="--repo"){ if(i+1<argc){ cfg.REPO=argv[++i]; ensureDir(cfg.REPO); } continue; }
        if(s=="--cache"){ if(i+1<argc){ cfg.CACHE=argv[++i]; ensureDir(cfg.CACHE); } continue; }
        if(s=="--work"){ if(i+1<argc){ cfg.WORK=argv[++i]; ensureDir(cfg.WORK); } continue; }
        if(s=="--db"){ if(i+1<argc){ cfg.DB=argv[++i]; ensureDir(cfg.DB); } continue; }
        if(s=="--log"){ if(i+1<argc){ cfg.LOG=argv[++i]; ensureDir(cfg.LOG); } continue; }
        if(s=="--pkgroot"){ if(i+1<argc){ cfg.PKGROOT=argv[++i]; ensureDir(cfg.PKGROOT); ensureDir(joinPath(cfg.PKGROOT,"bin")); } continue; }
        if(s=="--buildroot"){ if(i+1<argc){ cfg.BUILDROOT=argv[++i]; ensureDir(cfg.BUILDROOT); } continue; }
        if(s=="--binfmt"){ if(i+1<argc){ string v=argv[++i]; if(v=="zst"||v=="gz") global_binfmt=v; } continue; }

        // primeiro não-flag é comando
        if(a.cmd.empty()){ a.cmd=s; }
        else { a.args.push_back(s); }
    }
    if(getenv("NO_COLOR")) no_color=true;
    ensureBaseDirs();
    return a;
}

// ========================= main =========================
int main(int argc, char **argv){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    auto pa = parseArgs(argc, argv);
    string cmd = pa.cmd.empty()? string("help"): pa.cmd;
    auto args = pa.args;

    if(cmd=="help"||cmd=="-h"||cmd=="--help") { help(); return 0; }
    if(cmd=="init-repo") return action_init_repo(args);
    if(cmd=="sync") return action_sync(args);
    if(cmd=="new") return action_new(args);
    if(cmd=="search") return action_search(args);
    if(cmd=="info") return action_info(args);
    if(cmd=="build") return action_build(args);
    if(cmd=="install"||cmd=="in") return action_install(args);
    if(cmd=="remove"||cmd=="rm") return action_remove(args);
    if(cmd=="upgrade") return action_upgrade(args);
    if(cmd=="list") return action_list(args);
    if(cmd=="orphans") return action_orphans(args);
    if(cmd=="clean") return action_clean(args);

    cerr<<C(ansi::red)<<"Comando desconhecido: "<<cmd<<C(ansi::reset)<<"\n";
    help();
    return 1;
}

/* ========================= Exemplo de receita =========================
Salve como:
$REPO/base/gcc-12.0/gcc-12.0.fbuild

Conteúdo:

name=gcc
version=12.0.0
summary=GNU Compiler Collection
license=GPL-3.0
homepage=https://gcc.gnu.org/
source0=https://ftp.gnu.org/gnu/gcc/gcc-12.0.0/gcc-12.0.0.tar.xz
sha2560=<INSIRA_SHA256_CORRETO>
build_system=autotools
build_opts=--disable-multilib --enable-languages=c,c++ --with-system-zlib
# build_dir=gcc-12.0.0
depends=binutils zlib gmp mpfr mpc

========================= Notas =========================
- DESTDIR é utilizado para isolar a instalação prévia ao empacotamento binário.
- Pacotes binários são salvos em $FBUILD_PKGROOT/bin/<nome>-<versão>-<arch>.fbuildpkg + .sha256
- Na instalação a partir de binário, a verificação SHA256 é aplicada se o arquivo .sha256 existir.
- Hooks podem ser colocados em:
  * Globais: $REPO/hooks/<hook>.sh
  * Locais da receita: <dir_da_receita>/hooks/<hook>.sh
  Hooks suportados: pre-download, post-download, pre-patch, post-patch, pre-build, post-build, pre-install, post-install, pre-remove, post-remove
- Reverse-deps são mantidos em $DB/_reverse_deps (formato simples).
- Para segurança/robustez extra em produção:
  * substituir system() por execve/spawn
  * adicionar verificação GPG para tarballs
  * armazenar manifestos também dentro do .fbuildpkg para instalação binária com manifesto
*/
