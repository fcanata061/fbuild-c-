// fbuild - Gerenciador de programas source-based para LFS (versão corrigida, com deps e spinner)
// Linguagem: C++17
// Compilação: g++ -std=c++17 -O2 -pthread -o fbuild main.cpp
// Dependências: bash, git, curl, tar, unzip, xz, 7z, patch, zstd, sha256sum
//
// Novidades desta versão:
//  - Correções de bugs (isGitUrl, mensagem em remove, cmake/meson DESTDIR).
//  - Flags globais: -v/--verbose, -n/--no-color, -k/--keep-workdir, -f/--force, -jN/--jobs=N.
//  - Atalhos de subcomando: bi/build, in/install, rm/remove, dl/download.
//  - Resolução de dependências: varredura do repositório, escolha da melhor versão e ordenação topológica.
//  - Pula instalação se a mesma versão já estiver instalada (a menos que --force).
//  - Atualiza automaticamente quando a versão da receita for diferente da instalada.
//  - Spinner visual em passos longos.
//
// Observações:
//  - Mantém system()/bash -lc por simplicidade, porém com escapes e checagens.
//  - Verificação SHA256 é aplicada quando fornecida na receita.
//  - Manifesto separado para arquivos e diretórios; remoção segura só do que foi instalado.

#include <bits/stdc++.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <filesystem>

using namespace std;
namespace fs = std::filesystem;

// ========================= Utilidades ANSI =========================
namespace ansi {
    const string reset="\033[0m";
    const string bold="\033[1m";
    const string dim="\033[2m";
    const string red="\033[31m";
    const string green="\033[32m";
    const string yellow="\033[33m";
    const string blue="\033[34m";
    const string magenta="\033[35m";
    const string cyan="\033[36m";
    const string gray="\033[90m";
}

// ========================= Globais =========================
static bool verbose = false;        // habilitado por -v/--verbose
static bool no_color = false;       // habilitado por -n/--no-color
static bool keep_workdir = false;   // habilitado por -k/--keep-workdir
static bool force_install = false;  // habilitado por -f/--force
static int  jobs_override = 0;      // via -jN/--jobs=N

string C(string color){ return no_color? string("") : color; }

// Escape ingênuo porém seguro para bash -lc
string shellEscape(const string &s){
    string out; out.reserve(s.size()*2);
    for(unsigned char c: s){
        if(isalnum(c) || c=='/'||c=='_'||c=='.'||c=='-'||c=='+') out.push_back(c);
        else { out.push_back('\\'); out.push_back(c); }
    }
    return out;
}

// Executa no shell; se logfile não vazio, redireciona saída
int sh(const string &cmd, const string &logfile=""){
    if(verbose) cerr << C(ansi::gray) << "→ " << cmd << C(ansi::reset) << "\n";
    string real = cmd;
    if(!logfile.empty()){
        real = "bash -lc '" + cmd + "'"; // garantir bash para redirecionamento seguro
        real += " >>" + shellEscape(logfile) + " 2>&1";
        return system(real.c_str());
    }
    return system(cmd.c_str());
}

bool existsPath(const string &p){ return access(p.c_str(), F_OK)==0; }
string getenvs(const string &k, const string &def=""){ const char* v=getenv(k.c_str()); return v? string(v):def; }
string joinPath(const string &a, const string &b){ if(a.empty()) return b; if(a.back()=='/') return a+b; return a+"/"+b; }
string timestamp(){ time_t t=time(nullptr); char buf[64]; strftime(buf,64,"%Y-%m-%d_%H-%M-%S",localtime(&t)); return buf; }
void ensureDir(const string &p){ if(!existsPath(p)) { if(mkdir(p.c_str(), 0755)!=0){ perror(("mkdir "+p).c_str()); exit(1);} } }

// Verifica se binário está disponível no PATH
bool haveCmd(const string &cmd){ string c = "bash -lc 'command -v "+shellEscape(cmd)+" >/dev/null'"; return system(c.c_str())==0; }

void requireCmds(const vector<string>&cmds){
    vector<string> missing;
    for(auto &c:cmds){ if(!haveCmd(c)) missing.push_back(c); }
    if(!missing.empty()){
        cerr<<C(ansi::red)<<"Faltam dependências no PATH: ";
        for(size_t i=0;i<missing.size();++i){ cerr<<missing[i]<<(i+1<missing.size()?", ":""); }
        cerr<<C(ansi::reset)<<"\n"; exit(2);
    }
}

// ========================= Spinner =========================
class Spinner {
    atomic<bool> running{false};
    thread th; string msg;
public:
    void start(const string &m){ msg=m; running=true; th=thread([&]{
        const char* frames="|/-\\"; int i=0;
        while(running){ cerr << "\r" << C(ansi::cyan) << frames[i++%4] << C(ansi::reset) << " " << msg << "   "; cerr.flush(); this_thread::sleep_for(chrono::milliseconds(120)); }
        cerr << "\r" << string(msg.size()+6,' ') << "\r"; cerr.flush();
    }); }
    void stopOk(){ running=false; if(th.joinable()) th.join(); cerr << C(ansi::green) << "✔" << C(ansi::reset) << " " << msg << "\n"; }
    void stopFail(){ running=false; if(th.joinable()) th.join(); cerr << C(ansi::red) << "✖" << C(ansi::reset) << " " << msg << "\n"; }
};

// ========================= Config & paths =========================
struct Config{
    string REPO = getenvs("REPO", string(getenvs("HOME"))+"/fbuild-repo");
    string CACHE = getenvs("FB_CACHE", string(getenvs("HOME"))+"/.cache/fbuild");
    string WORK = getenvs("FB_WORK", string(getenvs("HOME"))+"/.local/share/fbuild/work");
    string PKG = getenvs("FB_PKG", string(getenvs("HOME"))+"/.local/share/fbuild/pkg");
    string DB = getenvs("FB_DB", string(getenvs("HOME"))+"/.local/share/fbuild/db");
    string LOG = getenvs("FB_LOG", string(getenvs("HOME"))+"/.local/share/fbuild/log");
    string DESTDIR = getenvs("DESTDIR", "/"); // raiz alvo
} cfg;

void ensureBaseDirs(){
    for(auto &d: {cfg.REPO, cfg.CACHE, cfg.WORK, cfg.PKG, cfg.DB, cfg.LOG}) ensureDir(d);
    for(auto &sub: {string("base"),string("x11"),string("extras"),string("desktop"),string("hooks")}) ensureDir(joinPath(cfg.REPO, sub));
}

// ========================= Formato de receita =========================
struct Recipe{
    string path;
    map<string,string> kv;
    vector<string> sources, sha256, patches, depends;
};

string trim(const string &s){ size_t a=s.find_first_not_of(" \t\r\n"); if(a==string::npos) return ""; size_t b=s.find_last_not_of(" \t\r\n"); return s.substr(a,b-a+1);}    

Recipe loadRecipe(const string &file){
    ifstream in(file); if(!in) { cerr<<C(ansi::red)<<"Erro abrindo receita: "<<file<<C(ansi::reset)<<"\n"; exit(1);}    
    Recipe r; r.path=file; string line; 
    while(getline(in,line)){
        line=trim(line); if(line.empty()||line[0]=='#'||line[0]=='[') continue;
        auto eq=line.find('='); if(eq==string::npos) continue; string k=trim(line.substr(0,eq)); string v=trim(line.substr(eq+1));
        if(k.rfind("source",0)==0){ r.sources.push_back(v); }
        else if(k.rfind("sha256",0)==0){ r.sha256.push_back(v); }
        else if(k.rfind("patch",0)==0){ r.patches.push_back(v); }
        else if(k=="depends"){ stringstream ss(v); string x; while(ss>>x) r.depends.push_back(x); }
        else r.kv[k]=v;
    }
    return r;
}

string recipeName(const Recipe &r){ auto it=r.kv.find("name"); return it==r.kv.end()?"":it->second; }
string recipeVersion(const Recipe &r){ auto it=r.kv.find("version"); return it==r.kv.end()?"":it->second; }
string workDir(const Recipe &r){ return joinPath(cfg.WORK, recipeName(r)+"-"+recipeVersion(r)); }
string buildDir(const Recipe &r){ string bd = r.kv.count("build_dir")? r.kv.at("build_dir"): string("."); return joinPath(workDir(r), bd); }
string pkgTar(const Recipe &r){ return joinPath(cfg.PKG, recipeName(r)+"-"+recipeVersion(r)+".tar.zst"); }
string dbDir(const Recipe &r){ return joinPath(cfg.DB, recipeName(r)); }
string manifestFilesPath(const Recipe &r){ return joinPath(dbDir(r), "manifest.files"); }
string manifestDirsPath(const Recipe &r){ return joinPath(dbDir(r), "manifest.dirs"); }

string installedVersionFromDB(const string &name){
    string d=joinPath(cfg.DB,name); string meta=joinPath(d,"meta");
    ifstream mi(meta); if(!mi) return "";
    string line;
    while(getline(mi,line)){
        if(line.rfind("version=",0)==0){
            return trim(line.substr(8));
        }
    }
    return "";
}

// ========================= Baixar, extrair, verificar =========================
static inline bool isGitUrl(const string &url){
    // corrigido: rfind (havia um bug com "rind")
    return (url.rfind("git://",0)==0) || (url.rfind("git@",0)==0) ||
           ((url.rfind("https://",0)==0 || url.rfind("http://",0)==0) && url.find(".git")!=string::npos);
}

int fetchOne(const string &url, const string &out){
    if(isGitUrl(url)){
        return sh("git clone --depth 1 "+shellEscape(url)+" "+shellEscape(out));
    } else {
        return sh("curl -L --fail --retry 3 -o "+shellEscape(out)+" "+shellEscape(url));
    }
}

int extract(const string &archive, const string &dest){
    string a=archive; 
    if(a.size()>4 && a.substr(a.size()-4)==".zip") return sh("unzip -q "+shellEscape(a)+" -d "+shellEscape(dest));
    if(a.find(".tar.")!=string::npos) return sh("tar -xf "+shellEscape(a)+" -C "+shellEscape(dest));
    if(a.size()>3 && (a.substr(a.size()-3)==".xz" || a.substr(a.size()-3)==".gz")) return sh("tar -xf "+shellEscape(a)+" -C "+shellEscape(dest));
    // fallback 7z
    return sh("7z x "+shellEscape(a)+" -o"+shellEscape(dest));
}

bool verifySha256(const string &file, const string &expected){
    if(expected.empty()) return true; // nada a verificar
    string cmd = "bash -lc 'sha256sum " + shellEscape(file) + " | awk \"{print $1}\"'";
    FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) return false; char buf[256]; string got;
    if(fgets(buf,sizeof(buf),pipe)) got = trim(string(buf));
    pclose(pipe);
    if(got.empty()) return false;
    if(got!=expected){
        cerr<<C(ansi::red)<<"SHA256 divergente: esperado="<<expected<<" obtido="<<got<<C(ansi::reset)<<"\n";
        return false;
    }
    return true;
}

int downloadSources(const Recipe &r, string &outDir){
    // Limpa workdir anterior (a menos que keep_workdir)
    if(existsPath(workDir(r)) && !keep_workdir) sh("rm -rf "+shellEscape(workDir(r)));
    ensureDir(workDir(r));

    for(size_t i=0;i<r.sources.size();++i){
        string url=r.sources[i];
        string cacheTarget = joinPath(cfg.CACHE, recipeName(r)+"-"+recipeVersion(r)+"-src"+to_string(i));
        if(isGitUrl(url)){
            string dest = joinPath(workDir(r), string("src")+to_string(i)); ensureDir(dest);
            int rc = sh("git clone --depth 1 "+shellEscape(url)+" "+shellEscape(dest)); if(rc!=0) return rc;
        } else {
            int rc = fetchOne(url, cacheTarget); if(rc!=0) return rc;
            string expected = (i<r.sha256.size()? r.sha256[i]: string(""));
            if(!verifySha256(cacheTarget, expected)) return 100; // código específico para checksum
            rc = extract(cacheTarget, workDir(r)); if(rc!=0) return rc;
        }
    }
    outDir = workDir(r);
    return 0;
}

int applyPatch(const string &patchPath, const string &dest){
    return sh("patch -p1 -d "+shellEscape(dest)+" < "+shellEscape(patchPath));
}

int applyPatches(const Recipe &r){
    string wd = workDir(r);
    for(auto &p : r.patches){
        string path=p;
        if(p.rfind("http://",0)==0 || p.rfind("https://",0)==0){
            string tmp = joinPath(cfg.CACHE, string("patch-")+to_string(hash<string>{}(p)));
            if(fetchOne(p,tmp)!=0) return 1; path=tmp;
        } else if(isGitUrl(p)){
            string tmpdir = joinPath(cfg.CACHE, string("patchrepo-")+to_string(hash<string>{}(p))); if(existsPath(tmpdir)) sh("rm -rf "+shellEscape(tmpdir)); ensureDir(tmpdir);
            if(sh("git clone --depth 1 "+shellEscape(p)+" "+shellEscape(tmpdir))!=0) return 1;
            string cmd = "bash -lc 'shopt -s nullglob; for f in " + shellEscape(tmpdir) + "/*.patch; do patch -p1 -d " + shellEscape(wd) + " < \"$f\"; done'";
            if(sh(cmd)!=0) return 1; 
            continue;
        }
        if(applyPatch(path, wd)!=0) return 1;
    }
    // patches locais do diretório da receita
    string pdir = joinPath(fs::path(r.path).parent_path().string(), "patches");
    if(existsPath(pdir)){
        string cmd = "bash -lc 'shopt -s nullglob; for f in " + shellEscape(pdir) + "/*.patch; do patch -p1 -d " + shellEscape(wd) + " < \"$f\"; done'";
        if(sh(cmd)!=0) return 1;
    }
    return 0;
}

// ========================= Hooks =========================
void runHook(const string &hook, const Recipe &r){
    string script = joinPath(joinPath(cfg.REPO, "hooks"), hook+".sh");
    if(existsPath(script)) {
        string cmd = "bash -lc '"+shellEscape(script)+" "+shellEscape(recipeName(r))+" "+shellEscape(recipeVersion(r))+"'";
        sh(cmd);
    }
}

// ========================= Build & Install =========================
int runBuildSystem(const Recipe &r, const string &log=""){
    string bs = r.kv.count("build_system")? r.kv.at("build_system"):"autotools";
    string dir = buildDir(r);
    int jobs = jobs_override>0? jobs_override : (int)max(1u, thread::hardware_concurrency());

    if(r.kv.count("pre_build")){
        if(sh("bash -lc 'cd "+shellEscape(dir)+" && "+r.kv.at("pre_build")+"'" , log) != 0) return 1;
    }
    if(r.kv.count("build")){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && "+r.kv.at("build")+"'" , log);
    }
    if(bs=="autotools"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && ./configure --prefix=/usr "+(r.kv.count("build_opts")?r.kv.at("build_opts"):string(""))+" && make -j"+to_string(jobs)+"'" , log);
    } else if(bs=="cmake"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && cmake -B build -S . -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr "+(r.kv.count("build_opts")?r.kv.at("build_opts"):string(""))+" && cmake --build build -j"+to_string(jobs)+"'" , log);
    } else if(bs=="meson"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && meson setup build --prefix=/usr "+(r.kv.count("build_opts")?r.kv.at("build_opts"):string(""))+" && meson compile -C build'" , log);
    }
    return 1;
}

int runInstall(const Recipe &r, const string &destdir, const string &log=""){
    string bs = r.kv.count("build_system")? r.kv.at("build_system"):"autotools";
    string dir = buildDir(r);
    if(r.kv.count("install")){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && DESTDIR="+shellEscape(destdir)+" "+r.kv.at("install")+"'" , log);
    }
    if(bs=="autotools"){
        return sh("bash -lc 'cd "+shellEscape(dir)+" && make DESTDIR="+shellEscape(destdir)+" install'" , log);
    } else if(bs=="cmake"){
        // cmake respeita DESTDIR via env
        return sh("bash -lc 'cd "+shellEscape(dir)+" && DESTDIR="+shellEscape(destdir)+" cmake --install build --prefix /usr --config Release --verbose'" , log);
    } else if(bs=="meson"){
        // meson também
        return sh("bash -lc 'cd "+shellEscape(dir)+" && DESTDIR="+shellEscape(destdir)+" meson install -C build'" , log);
    }
    return 1;
}

// ========================= DB & Logs =========================
void dbRegister(const Recipe &r){
    string d=dbDir(r); ensureDir(d);
    ofstream meta(joinPath(d, "meta"));
    meta << "name="<<recipeName(r)<<"\n";
    meta << "version="<<recipeVersion(r)<<"\n";
    meta << "install_time="<<timestamp()<<"\n";
}

void dbUnregister(const string &name){
    string d=joinPath(cfg.DB, name);
    if(existsPath(d)) sh("rm -rf "+shellEscape(d));
}

string actionLog(const string &name,const string &action){ return joinPath(cfg.LOG, name+"-"+action+"-"+timestamp()+".log"); }

// ========================= Empacotamento & manifesto =========================
int makePkgFromDest(const Recipe &r, const string &destdir){
    string pkg = pkgTar(r);
    string cmd = "bash -lc 'cd "+shellEscape(destdir)+" && tar -I zstd -cf "+shellEscape(pkg)+" .'";
    return sh(cmd);
}

int writeManifestFromDest(const Recipe &r, const string &destdir){
    string d = dbDir(r); ensureDir(d);
    // Arquivos
    {
        ofstream mf(manifestFilesPath(r)); if(!mf) return 1;
        string cmd = "bash -lc 'cd "+shellEscape(destdir)+" && find . -type f -o -type l | sed \"s#^\\./##\" | sort'";
        FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) return 1; char buf[4096];
        while(fgets(buf,sizeof(buf),pipe)){
            string rel=string(buf); rel.erase(remove(rel.begin(), rel.end(),'\n'), rel.end()); if(rel.empty()) continue; 
            mf << joinPath(cfg.DESTDIR, rel) << "\n"; 
        }
        pclose(pipe);
    }
    // Diretórios (para remoção posterior, do mais profundo ao mais raso)
    {
        ofstream md(manifestDirsPath(r)); if(!md) return 1;
        string cmd = "bash -lc 'cd "+shellEscape(destdir)+" && find . -type d | sed \"s#^\\./##\" | sort -r'";
        FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) return 1; char buf[4096];
        vector<string> dirs;
        while(fgets(buf,sizeof(buf),pipe)){
            string rel=string(buf); rel.erase(remove(rel.begin(), rel.end(),'\n'), rel.end()); if(rel==".") continue; 
            dirs.push_back(joinPath(cfg.DESTDIR, rel));
        }
        pclose(pipe);
        for(auto &d: dirs) md<<d<<"\n";
    }
    return 0;
}

int installPkgToRoot(const Recipe &r, const string &pkg){
    string root = cfg.DESTDIR;
    return sh("tar -I zstd -xf "+shellEscape(pkg)+" -C "+shellEscape(root));
}

// ========================= Busca/Receitas =========================
vector<string> findAllRecipes(){
    vector<string> found; 
    for(const string &cat: {"base","x11","extras","desktop"}){
        string cdir = joinPath(cfg.REPO, cat);
        string cmd = "bash -lc 'shopt -s globstar nullglob; for f in " + shellEscape(cdir) + "/**/*.fbuild; do echo \"$f\"; done'";
        FILE* pipe=popen(cmd.c_str(), "r"); if(!pipe) continue; char buf[4096];
        while(fgets(buf,sizeof(buf),pipe)){
            string p=trim(buf); if(!p.empty()) found.push_back(p);
        }
        pclose(pipe);
    }
    return found;
}

vector<string> findRecipesByName(const string &query){
    vector<string> all = findAllRecipes(), found;
    for(auto &p: all){
        string base=fs::path(p).filename().string();
        if(query.empty() || base.find(query)!=string::npos) found.push_back(p);
    }
    return found;
}

// ========================= Comparação de versões =========================
// Compara versões tipo "1.2.10" vs "1.2.9" (numeric-aware). Retorna -1/0/1.
bool isDigits(const string& s){ return !s.empty() && all_of(s.begin(), s.end(), ::isdigit); }

vector<string> splitVer(const string& v){
    vector<string> out; string cur;
    auto flush=[&]{ if(!cur.empty()){ out.push_back(cur); cur.clear(); } };
    for(char c: v){
        if(c=='.' || c=='-' || c=='_'){ flush(); }
        else cur.push_back(c);
    }
    flush(); 
    return out;
}
int cmpVersion(const string& a, const string& b){
    auto A=splitVer(a), B=splitVer(b);
    size_t n=max(A.size(), B.size());
    for(size_t i=0;i<n;i++){
        string x = i<A.size()?A[i]:"0";
        string y = i<B.size()?B[i]:"0";
        if(isDigits(x) && isDigits(y)){
            long long xi=stoll(x), yi=stoll(y);
            if(xi<yi) return -1; if(xi>yi) return 1;
        } else {
            int c = x.compare(y);
            if(c<0) return -1; if(c>0) return 1;
        }
    }
    return 0;
}

// ========================= Índice de receitas & resolução de deps =========================
struct Indexed {
    Recipe r;
};

unordered_map<string, Indexed> indexRecipesBestByName(){
    unordered_map<string, Indexed> idx;
    for(auto &path: findAllRecipes()){
        Recipe r = loadRecipe(path);
        string name=recipeName(r), ver=recipeVersion(r);
        if(name.empty()||ver.empty()) continue;
        if(!idx.count(name) || cmpVersion(ver, recipeVersion(idx[name].r))>0){
            idx[name] = {r};
        }
    }
    return idx;
}

// DFS + ordenação topológica por nome (usa melhor versão do índice)
struct DepResolver {
    unordered_map<string, Indexed> idx;
    unordered_map<string,int> state; // 0=novo,1=visitando,2=feito
    vector<Recipe> order;            // resultado topológico
    unordered_set<string> added;     // nomes já adicionados

    DepResolver(unordered_map<string, Indexed> i):idx(std::move(i)){}

    void dfsUseRecipe(const Recipe& r){
        string name=recipeName(r);
        if(state[name]==1){ throw runtime_error("Ciclo de dependências detectado em: "+name); }
        if(state[name]==2) return;
        state[name]=1;
        for(auto &dep: r.depends){
            if(idx.count(dep)==0) throw runtime_error("Dependência não encontrada no repositório: "+dep);
            dfsUseRecipe(idx[dep].r);
        }
        state[name]=2;
        if(!added.count(name)){ order.push_back(r); added.insert(name); }
    }

    // usa a receita raiz exata (não substitui por "melhor")
    vector<Recipe> resolveFromRoot(const Recipe& root){
        // Garante que todas as dependências estão indexadas
        // (se faltar, dfs dispara exceção)
        dfsUseRecipe(root);
        return order;
    }
};

// ========================= Ações =========================
int action_sync(const vector<string>&){
    if(!existsPath(joinPath(cfg.REPO, ".git"))){
        cerr<<C(ansi::yellow)<<"Aviso: REPO não é um repositório git. Pulando."<<C(ansi::reset)<<"\n";
        return 0;
    }
    Spinner sp; sp.start("Sincronizando repositório");
    int rc = sh("git -C "+shellEscape(cfg.REPO)+" pull --ff-only");
    if(rc==0) sp.stopOk(); else sp.stopFail();
    return rc;
}

int action_new(const vector<string>&args){
    if(args.size()<2){ cerr<<"Uso: fbuild new <categoria> <nome> <versão>\n"; return 1; }
    string cat=args[0]; string name=args[1]; string ver=args.size()>=3?args[2]:"1.0";
    string dir = joinPath(joinPath(cfg.REPO, cat), name+"-"+ver);
    ensureDir(dir);
    string file = joinPath(dir, name+"-"+ver+".fbuild");
    ofstream f(file);
    f << "# Exemplo de receita fbuild\n";
    f << "name="<<name<<"\nversion="<<ver<<"\nsummary=\nlicense=\nhomepage=\n";
    f << "source0=\n# sha2560=\n# patch0=\n";
    f << "build_system=autotools\n# build_opts=\n# pre_build=\n# build=\n# install=\n# build_dir=.\n# depends=\n";
    cout<<file<<" criado.\n";
    return 0;
}

int action_search(const vector<string>&args){ string q = args.size()? args[0]: string(""); for(auto &p: findRecipesByName(q)) cout<<p<<"\n"; return 0; }

int action_info(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild info <arquivo .fbuild>\n"; return 1; }
    Recipe r=loadRecipe(args[0]);
    cout<<C(ansi::bold)<<recipeName(r)<<" "<<recipeVersion(r)<<C(ansi::reset)<<"\n";
    for(auto &kv: r.kv) cout<<kv.first<<"="<<kv.second<<"\n";
    for(size_t i=0;i<r.sources.size();++i) cout<<"source"<<i<<"="<<r.sources[i]<<"\n";
    for(size_t i=0;i<r.patches.size();++i) cout<<"patch"<<i<<"="<<r.patches[i]<<"\n";
    for(size_t i=0;i<r.sha256.size();++i) cout<<"sha256"<<i<<"="<<r.sha256[i]<<"\n";
    for(size_t i=0;i<r.depends.size();++i) cout<<"depends+="<<r.depends[i]<<"\n";
    return 0;
}

int action_download(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild download <.fbuild>\n"; return 1; }
    requireCmds({"bash","git","curl","tar","unzip","xz","7z"});
    Recipe r=loadRecipe(args[0]); runHook("pre-download", r);
    string out; Spinner sp; sp.start("Baixando fontes de "+recipeName(r));
    int rc=downloadSources(r,out); if(rc==0) sp.stopOk(); else sp.stopFail();
    runHook("post-download", r); 
    return rc;
}

int action_unpack(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild unpack <.fbuild>\n"; return 1; }
    requireCmds({"bash","git","curl","tar","unzip","xz","7z","patch","sha256sum"});
    Recipe r=loadRecipe(args[0]); runHook("pre-download", r);
    string out; Spinner sp1; sp1.start("Baixando "+recipeName(r));
    if(downloadSources(r,out)!=0){ sp1.stopFail(); return 1; } sp1.stopOk();
    runHook("post-download", r);
    runHook("pre-patch", r); Spinner sp2; sp2.start("Aplicando patches em "+recipeName(r));
    int rc=applyPatches(r); if(rc==0) sp2.stopOk(); else sp2.stopFail();
    runHook("post-patch", r); 
    return rc;
} 

int action_patch(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild patch <.fbuild>\n"; return 1; }
    requireCmds({"bash","patch"});
    Recipe r=loadRecipe(args[0]); runHook("pre-patch", r);
    Spinner sp; sp.start("Aplicando patches em "+recipeName(r));
    int rc=applyPatches(r); if(rc==0) sp.stopOk(); else sp.stopFail();
    runHook("post-patch", r); return rc;
} 

// ---------- Instala um pacote (sem deps). Usado internamente pelo resolvedor ----------
int do_install_single(const Recipe &r){
    requireCmds({"bash","git","curl","tar","unzip","xz","7z","patch","sha256sum","zstd"});

    // Skip se já instalado na mesma versão (a menos que --force)
    string installedVer = installedVersionFromDB(recipeName(r));
    if(!force_install && !installedVer.empty() && installedVer==recipeVersion(r)){
        cout<<C(ansi::yellow)<<"Já instalado (mesma versão): "<<recipeName(r)<<"-"<<recipeVersion(r)<<C(ansi::reset)<<"\n";
        return 0;
    }
    if(!installedVer.empty() && installedVer!=recipeVersion(r)){
        cout<<C(ansi::blue)<<"Atualizando "<<recipeName(r)<<" "<<installedVer<<" → "<<recipeVersion(r)<<C(ansi::reset)<<"\n";
    }

    string log = actionLog(recipeName(r), "install");
    // download
    runHook("pre-download", r); string out; {
        Spinner sp; sp.start("Baixando "+recipeName(r));
        int rc=downloadSources(r,out); if(rc!=0){ sp.stopFail(); cerr<<"download falhou\n"; return 1; }
        sp.stopOk();
    } runHook("post-download", r);

    // patches
    runHook("pre-patch", r); {
        Spinner sp; sp.start("Patch "+recipeName(r));
        if(applyPatches(r)!=0){ sp.stopFail(); cerr<<"patch falhou\n"; return 1; }
        sp.stopOk();
    } runHook("post-patch", r);

    // build
    runHook("pre-build", r); {
        Spinner sp; sp.start("Build "+recipeName(r));
        if(runBuildSystem(r, log)!=0){ sp.stopFail(); cerr<<"build falhou\n"; return 1; }
        sp.stopOk();
    } runHook("post-build", r);

    // install em DESTDIR temporário
    string tmpdest = joinPath(cfg.WORK, string("dest-")+recipeName(r)+"-"+recipeVersion(r));
    if(existsPath(tmpdest) && !keep_workdir) sh("rm -rf "+shellEscape(tmpdest));
    ensureDir(tmpdest);

    runHook("pre-install", r);
    {
        Spinner sp; sp.start("Install (DESTDIR) "+recipeName(r));
        if(runInstall(r, tmpdest, log)!=0){ sp.stopFail(); cerr<<"install (fase em DESTDIR) falhou\n"; if(!keep_workdir) sh("rm -rf "+shellEscape(tmpdest)); return 1; }
        sp.stopOk();
    }

    // manifesto + pacote
    if(writeManifestFromDest(r, tmpdest)!=0) cerr<<C(ansi::yellow)<<"Aviso: não foi possível gerar manifesto"<<C(ansi::reset)<<"\n";
    {
        Spinner sp; sp.start("Empacotando "+recipeName(r));
        if(makePkgFromDest(r, tmpdest)!=0){ sp.stopFail(); cerr<<"empacotamento falhou\n"; return 1; }
        sp.stopOk();
    }

    // instalação no root
    {
        Spinner sp; sp.start("Instalando na raiz "+recipeName(r));
        if(installPkgToRoot(r, pkgTar(r))!=0){ sp.stopFail(); cerr<<"instalação no root falhou\n"; return 1; }
        sp.stopOk();
    }
    runHook("post-install", r);

    dbRegister(r);
    cout<<C(ansi::green)<<"Instalado: "<<recipeName(r)<<"-"<<recipeVersion(r)<<C(ansi::reset)<<"\n";

    // limpeza de temporários
    if(!keep_workdir){
        sh("rm -rf "+shellEscape(tmpdest));
        // opcional: limpar source/build
        // sh("rm -rf "+shellEscape(workDir(r)));
    }
    return 0;
}

// ---------- Instala com resolução de dependências ----------
int action_install(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild install <arquivo .fbuild>\n"; return 1; }
    Recipe root = loadRecipe(args[0]);

    // Indexa repositório e resolve a ordem
    auto idx = indexRecipesBestByName();
    // garante que o pacote raiz (exato) esteja no índice também (com sua versão)
    idx[recipeName(root)] = {root};

    DepResolver R(idx);
    vector<Recipe> ordered;
    try{
        ordered = R.resolveFromRoot(root);
    }catch(const exception& e){
        cerr<<C(ansi::red)<<"Erro de dependências: "<<e.what()<<C(ansi::reset)<<"\n";
        return 1;
    }

    // Exibe ordem (deps → alvo)
    cout<<C(ansi::bold)<<"Ordem de instalação:"<<C(ansi::reset)<<"\n";
    for(auto &r: ordered) cout<<"  - "<<recipeName(r)<<" "<<recipeVersion(r)<<"\n";

    // Instala na ordem
    for(auto &r: ordered){
        if(do_install_single(r)!=0) return 1;
    }
    return 0;
}

// ---------- Apenas compila (sem instalar), sem deps ----------
int action_build(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild build <.fbuild>\n"; return 1; }
    requireCmds({"bash","git","curl","tar","unzip","xz","7z","patch","sha256sum"});

    Recipe r=loadRecipe(args[0]);
    runHook("pre-download", r); string out; {
        Spinner sp; sp.start("Baixando "+recipeName(r));
        if(downloadSources(r,out)!=0){ sp.stopFail(); return 1; } sp.stopOk();
    } runHook("post-download", r);
    runHook("pre-patch", r); {
        Spinner sp; sp.start("Patch "+recipeName(r));
        if(applyPatches(r)!=0){ sp.stopFail(); return 1; } sp.stopOk();
    } runHook("post-patch", r);
    runHook("pre-build", r); {
        Spinner sp; sp.start("Build "+recipeName(r));
        int rc=runBuildSystem(r); if(rc!=0){ sp.stopFail(); return rc; } sp.stopOk();
    } runHook("post-build", r);
    return 0;
}

int action_remove(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild remove <nome>\n"; return 1; }
    string name=args[0];

    // Recupera versão do DB para hooks
    Recipe dummy; dummy.kv["name"]=name; dummy.kv["version"]="unknown";
    string d=joinPath(cfg.DB,name);
    string meta=joinPath(d,"meta");
    ifstream mi(meta); if(mi){ string line; while(getline(mi,line)){ if(line.rfind("version=",0)==0) dummy.kv["version"]=trim(line.substr(8)); } }

    runHook("pre-remove", dummy);

    string mfpath = joinPath(d,"manifest.files");
    string mdpath = joinPath(d,"manifest.dirs");

    // Remoção de arquivos listados
    ifstream mf(mfpath);
    if(mf){
        vector<string> files; string path;
        while(getline(mf,path)){ path=trim(path); if(!path.empty()) files.push_back(path); }
        for(auto it=files.rbegin(); it!=files.rend(); ++it){
            string cmd = "bash -lc 'if [ -e " + shellEscape(*it) + " ] || [ -L " + shellEscape(*it) + " ]; then rm -f " + shellEscape(*it) + "; fi'";
            sh(cmd);
        }
    } else {
        cerr<<C(ansi::yellow)<<"Aviso: manifest.files ausente; não é possível remover arquivos"<<C(ansi::reset)<<"\n";
    }

    // Remoção de diretórios *apenas* os listados (profundo → raso)
    ifstream md(mdpath);
    if(md){
        vector<string> dirs; string path; while(getline(md,path)){ path=trim(path); if(!path.empty()) dirs.push_back(path); }
        for(auto &dir: dirs){ string cmd = "bash -lc 'if [ -d " + shellEscape(dir) + " ] && [ -z \"$(ls -A " + shellEscape(dir) + ")\" ]; then rmdir " + shellEscape(dir) + "; fi'"; sh(cmd); }
    } else {
        cerr<<C(ansi::yellow)<<"Aviso: manifest.dirs ausente; diretórios não foram removidos"<<C(ansi::reset)<<"\n";
    }

    dbUnregister(name);
    runHook("post-remove", dummy);
    cout<<C(ansi::yellow)<<"Removido (arquivos/diretórios listados): "<<name<<C(ansi::reset)<<"\n";
    return 0;
}

int action_upgrade(const vector<string>&args){ if(args.empty()){ cerr<<"Uso: fbuild upgrade <nova_receita.fbuild>\n"; return 1; } return action_install(args); }

int action_clean(const vector<string>&){ sh("rm -rf "+shellEscape(cfg.WORK)); ensureDir(cfg.WORK); cout<<"WORK limpo.\n"; return 0; }

// Lista pacotes instalados (pela base de dados)
int action_list(const vector<string>&){
    if(!existsPath(cfg.DB)){ cout<<"(nenhum instalado)\n"; return 0; }
    for(auto &entry: fs::directory_iterator(cfg.DB)){
        if(!entry.is_directory()) continue;
        string name = entry.path().filename().string();
        string ver = installedVersionFromDB(name);
        cout<<name<<(ver.empty()?"":"-")+ver<<"\n";
    }
    return 0;
}

// Mostra ordem de deps sem instalar
int action_deps(const vector<string>&args){
    if(args.empty()){ cerr<<"Uso: fbuild deps <arquivo .fbuild>\n"; return 1; }
    Recipe root = loadRecipe(args[0]);
    auto idx = indexRecipesBestByName();
    idx[recipeName(root)] = {root};
    DepResolver R(idx);
    vector<Recipe> ordered;
    try{ ordered = R.resolveFromRoot(root); }
    catch(const exception& e){ cerr<<C(ansi::red)<<"Erro de dependências: "<<e.what()<<C(ansi::reset)<<"\n"; return 1; }
    cout<<C(ansi::bold)<<"Ordem resolvida:"<<C(ansi::reset)<<"\n";
    for(auto &r: ordered) cout<<"  - "<<recipeName(r)<<" "<<recipeVersion(r)<<"\n";
    return 0;
}

// ========================= Ajuda =========================
void help(){
    cout<<"fbuild - gerenciador source-based (com deps e spinner)\n\n";
    cout<<"Variáveis (export): REPO, FB_CACHE, FB_WORK, FB_PKG, FB_DB, FB_LOG, DESTDIR\n\n";
    cout<<"Flags globais: -v/--verbose  -n/--no-color  -k/--keep-workdir  -f/--force  -jN/--jobs=N\n\n";
    cout<<"Comandos:\n";
    cout<<"  init-repo                         # cria estrutura $REPO/{base,x11,extras,desktop}\n";
    cout<<"  new <categoria> <nome> <ver>      # cria pasta e receita .fbuild\n";
    cout<<"  sync                              # git pull no REPO\n";
    cout<<"  search [termo]                    # procura receitas\n";
    cout<<"  info <arquivo.fbuild>             # mostra metadados\n";
    cout<<"  deps <arquivo.fbuild>             # mostra ordem de dependências\n";
    cout<<"  download|dl <arquivo.fbuild>      # baixa fontes (com SHA256 opcional)\n";
    cout<<"  unpack <arquivo.fbuild>           # baixa + descompacta + aplica patches\n";
    cout<<"  patch <arquivo.fbuild>            # aplica patches (se já extraído)\n";
    cout<<"  build|bi <arquivo.fbuild>         # compila sem instalar\n";
    cout<<"  install|in <arquivo.fbuild>       # resolve deps e instala (pula mesmo ver.)\n";
    cout<<"  remove|rm <nome>                  # remove via manifest.files/.dirs\n";
    cout<<"  upgrade <nova_receita.fbuild>     # instala versão maior (usa install)\n";
    cout<<"  list                              # lista pacotes instalados\n";
    cout<<"  clean                             # limpa WORK\n";
    cout<<"  help                              # esta ajuda\n\n";
}

// ========================= Parse flags globais =========================
void parse_global_flags(int &argc, char **&argv){
    // Flags globais ficam ANTES do subcomando: fbuild [flags] <cmd> ...
    vector<char*> newArgs; newArgs.push_back(argv[0]);
    for(int i=1;i<argc;i++){
        string a=argv[i];
        auto push=[&]{ newArgs.push_back(argv[i]); };
        if(a=="-v"||a=="--verbose"){ verbose=true; continue; }
        if(a=="-n"||a=="--no-color"){ no_color=true; continue; }
        if(a=="-k"||a=="--keep-workdir"){ keep_workdir=true; continue; }
        if(a=="-f"||a=="--force"){ force_install=true; continue; }
        if(a.rfind("-j",0)==0 && a.size()>2){ jobs_override=stoi(a.substr(2)); continue; }
        if(a.rfind("--jobs=",0)==0){ jobs_override=stoi(a.substr(7)); continue; }
        // não é flag global → mantém
        push();
    }
    // reconstroi argv/argc
    int n=newArgs.size();
    for(int i=0;i<n;i++) argv[i]=newArgs[i];
    argc=n;
}

// ========================= main =========================
int main(int argc, char **argv){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    if(getenv("NO_COLOR")) no_color=true; 
    ensureBaseDirs();

    parse_global_flags(argc, argv);

    string cmd = argc>=2? string(argv[1]): string("help");
    vector<string> args; for(int i=2;i<argc;i++) args.push_back(argv[i]);

    if(cmd=="help"||cmd=="-h"||cmd=="--help") { help(); return 0; }
    if(cmd=="init-repo") return action_init_repo(args);
    if(cmd=="sync") return action_sync(args);
    if(cmd=="new") return action_new(args);
    if(cmd=="search") return action_search(args);
    if(cmd=="info") return action_info(args);
    if(cmd=="deps") return action_deps(args);
    if(cmd=="download"||cmd=="dl") return action_download(args);
    if(cmd=="unpack") return action_unpack(args);
    if(cmd=="patch") return action_patch(args);
    if(cmd=="build"||cmd=="bi") return action_build(args);
    if(cmd=="install"||cmd=="in") return action_install(args);
    if(cmd=="remove"||cmd=="rm") return action_remove(args);
    if(cmd=="upgrade") return action_upgrade(args);
    if(cmd=="list") return action_list(args);
    if(cmd=="clean") return action_clean(args);

    cerr<<C(ansi::red)<<"Comando desconhecido: "<<cmd<<C(ansi::reset)<<"\n";
    help();
    return 1;
}

/* ========================= Exemplo de receita =========================
Salve como:
$REPO/base/gcc-12.0/gcc-12.0.fbuild

Conteúdo:

name=gcc
version=12.0.0
summary=GNU Compiler Collection
license=GPL-3.0
homepage=https://gcc.gnu.org/
source0=https://ftp.gnu.org/gnu/gcc/gcc-12.0.0/gcc-12.0.0.tar.xz
sha2560=<INSIRA_SHA256_CORRETO>
build_system=autotools
build_opts=--disable-multilib --enable-languages=c,c++
# build_dir=gcc-12.0.0
# depends=binutils zlib gmp mpfr mpc

========================= Notas =========================
- SHA256 é verificado quando informado.
- Remoção usa apenas manifestos gerados no install.
- Resolução de dependências varre todo o $REPO e escolhe a melhor versão.
- Usa DESTDIR corretamente para cmake/meson.
- Flags globais: -v, -n, -k, -f, -jN.
*/
